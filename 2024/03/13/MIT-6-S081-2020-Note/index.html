<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
    <title>
      MIT 6.S081 2020 学习笔记 | sev1n75 | Binary Exploit</title>

  
  <meta name="author" content="sev1n75">
  

  
  <meta name="description" content="CTF Pwn 选手，以此博客分享技术和学习过程">
  

  
  
  <meta name="keywords" content="OS,MIT,Experiment">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="MIT 6.S081 2020 学习笔记"/>

  <meta property="og:site_name" content="sev1n75"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/images/favicon.png" type="image/png" rel="icon">
  <link href="/images/favicon.png" rel="apple-touch-icon" sizes="76x76">
  <link rel="alternate" href="/atom.xml" title="sev1n75" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <link href="https://fonts.lug.ustc.edu.cn/css?family=Lato|Rubik" rel="stylesheet">
  <script src="/js/pangu-407.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>
<script>
  document.addEventListener(' DOMContentLoaded', () => {
    pangu.autoSpacingPage();
  });
</script>

<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">
        sev1n75's Tech Blog
      </a>
    </h1>
    <p class="site-description">
      
        路漫漫其修远兮，吾将上下而求索
          
    </p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">
            主页
          </a></li>
        
        <li><a href="/archives">
            归档
          </a></li>
        
        <li><a href="/tags">
            标签
          </a></li>
        
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>MIT 6.S081 2020 学习笔记</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/13/MIT-6-S081-2020-Note/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-13T07:36:07.000Z">
          2024-03-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        

<script type="text/javascript">
    function convertRemToPixels(rem) {    
        return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
    window.onscroll = function() {
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop > convertRemToPixels(40)) {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'visible';
        } else {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'hidden';
        }
    }
</script>


<div id="toc" class="toc-article">
      <div class="toc-content">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-text">| 0 | 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lab-util-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 1 | Lab util 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-LEC-1-amp-Chapter-1-note"><span class="toc-text">| 1.1 | LEC 1  &amp; Chapter 1 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-LEC-2-note"><span class="toc-text">| 1.2 | LEC 2 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Lab-Xv6-and-Unix-utilities"><span class="toc-text">| 1.3 | Lab: Xv6 and Unix utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-Boot-xv6-easy"><span class="toc-text">| 1.3.1 | Boot xv6 (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-sleep-easy"><span class="toc-text">| 1.3.2 | sleep (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-pingpong-easy"><span class="toc-text">| 1.3.3 | pingpong (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-primes-moderate-x2F-hard"><span class="toc-text">| 1.3.4 | primes (moderate)&#x2F;(hard)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-find-moderate-amp-xargs-moderate"><span class="toc-text">| 1.3.5 | find (moderate) &amp; xargs (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Lab-syscall-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 2 | Lab syscall 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Chapter-2-note-amp-LEC-3-note"><span class="toc-text">| 2.1 | Chapter 2 note &amp; LEC 3 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Abstracting-physical-resources"><span class="toc-text">| 2.1.1 | Abstracting physical resources</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-User-mode-supervisor-mode-and-system-calls"><span class="toc-text">| 2.1.2 | User mode, supervisor mode, and system calls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Kernel-organization"><span class="toc-text">| 2.1.3 | Kernel organization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-Process-overview"><span class="toc-text">| 2.1.4 | Process overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-Code-starting-xv6-and-the-first-process"><span class="toc-text">| 2.1.5 | Code: starting xv6 and the first process</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Lab-system-calls"><span class="toc-text">| 2.2 | Lab: system calls</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-System-call-tracing-moderate"><span class="toc-text">| 2.2.1 | System call tracing (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Sysinfo-moderate"><span class="toc-text">| 2.2.2 | Sysinfo (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Lab-pgtbl-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 3 | Lab pgtbl 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Chapter-3-amp-LEC-4-note"><span class="toc-text">| 3.1 | Chapter 3 &amp; LEC 4 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-Paging-hardware"><span class="toc-text">| 3.1.1 | Paging hardware</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-Kernel-address-space"><span class="toc-text">| 3.1.2 | Kernel address space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-Code-creating-an-address-space"><span class="toc-text">| 3.1.3 | Code: creating an address space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-Code-exec"><span class="toc-text">| 3.1.4 | Code: exec</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-LEC-5-note"><span class="toc-text">| 3.2 | LEC 5 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Lab-page-tables"><span class="toc-text">| 3.3 | Lab: page tables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-Print-a-page-table-easy"><span class="toc-text">| 3.3.1 | Print a page table (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-A-kernel-page-table-per-process-hard"><span class="toc-text">| 3.3.2 | A kernel page table per process (hard)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-Simplify-copyin-copyinstr-hard"><span class="toc-text">| 3.3.3 | Simplify copyin&#x2F;copyinstr (hard)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Lab-trap-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 4 | Lab trap 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Chapter-4-amp-LEC-6-note"><span class="toc-text">| 4.1 | Chapter 4 &amp; LEC 6 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-RISC-V-trap-machinery"><span class="toc-text">| 4.1.1 | RISC-V trap machinery</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-Traps-from-user-space"><span class="toc-text">| 4.1.2 | Traps from user space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Traps-from-kernel-space"><span class="toc-text">| 4.1.3 | Traps from kernel space</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Lab-traps"><span class="toc-text">| 4.2 | Lab: traps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-RISC-V-assembly-easy"><span class="toc-text">| 4.2.1 | RISC-V assembly (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-Backtrace-moderate"><span class="toc-text">| 4.2.2 | Backtrace (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-Alarm-hard"><span class="toc-text">| 4.2.3 | Alarm (hard)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Lab-lazy-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 5 | Lab lazy 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Chapter-4-6-amp-LEC-8-note"><span class="toc-text">| 5.1 | Chapter 4.6 &amp; LEC 8 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-Lazy-Allocation"><span class="toc-text">| 5.1.1 | Lazy Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-Copy-On-Write-COW-fork"><span class="toc-text">| 5.1.2 | Copy-On-Write (COW) fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E5%85%B6%E4%BB%96"><span class="toc-text">| 5.1.3 | 其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Chapter-5-amp-LEC-9-note"><span class="toc-text">| 5.2 | Chapter 5 &amp; LEC 9 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-Code-Console-input-x2F-output"><span class="toc-text">| 5.2.1 | Code: Console input&#x2F;output</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-Timer-interrupts"><span class="toc-text">| 5.2.2 | Timer interrupts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Lab-xv6-lazy-page-allocation"><span class="toc-text">| 5.3 | Lab: xv6 lazy page allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-Lazy-allocation-moderate-amp-amp-Lazytests-and-Usertests-moderate"><span class="toc-text">| 5.3.1 | Lazy allocation (moderate) &amp;&amp; Lazytests and Usertests (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Lab-cow-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 6 | Lab cow 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Lab-Copy-on-Write-Fork-for-xv6"><span class="toc-text">| 6.1 | Lab: Copy-on-Write Fork for xv6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Lab-thread-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 7 | Lab thread 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Chapter-6-amp-LEC-10-note"><span class="toc-text">| 7.1 | Chapter 6 &amp; LEC 10 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Chapter-7-amp-LEC-11-note-amp-LEC-13-note"><span class="toc-text">| 7.2 | Chapter 7 &amp; LEC 11 note &amp; LEC 13 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-switch-amp-scheduling"><span class="toc-text">| 7.2.1 | switch &amp; scheduling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-sleep-amp-wakeup"><span class="toc-text">| 7.2.2 | sleep &amp; wakeup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-wait-exit-amp-kill"><span class="toc-text">| 7.2.3 | wait, exit &amp; kill</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-Lab-Multithreading"><span class="toc-text">| 7.3 | Lab: Multithreading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-Uthread-switching-between-threads-moderate"><span class="toc-text">| 7.3.1 | Uthread: switching between threads (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-Using-threads-moderate"><span class="toc-text">| 7.3.2 | Using threads (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-Barrier-moderate"><span class="toc-text">| 7.3.3 | Barrier(moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Lab-lock-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 8 | Lab lock 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Lab-locks"><span class="toc-text">| 8.1 | Lab: locks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-Memory-allocator-moderate"><span class="toc-text">| 8.1.1 | Memory allocator (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-Buffer-cache-hard"><span class="toc-text">| 8.1.2 | Buffer cache (hard)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Lab-fs-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 9 | Lab fs 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-LEC-14-note"><span class="toc-text">| 9.1 | LEC 14 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-Buffer-cache-layer"><span class="toc-text">|9.1.1| Buffer cache layer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-inode-layer-icache"><span class="toc-text">|9.1.2| inode layer(icache)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-LEC-15-note-amp-Chapter-8"><span class="toc-text">| 9.2 | LEC 15 note &amp; Chapter 8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-logging-layer"><span class="toc-text">|9.2.1| logging layer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-Directory-pathname-file-descriptor-layer"><span class="toc-text">|9.2.2| Directory, pathname, file descriptor layer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-LEC-16-note"><span class="toc-text">| 9.3 | LEC 16 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Lab-file-system"><span class="toc-text">| 9.4 | Lab: file system</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-Large-files-moderate"><span class="toc-text">| 9.4.1 | Large files (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-Symbolic-links-moderate"><span class="toc-text">| 9.4.2 | Symbolic links (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Lab-mmap-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 10 | Lab mmap 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-LEC-17-note"><span class="toc-text">| 10.1 | LEC 17 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-LEC-18-note"><span class="toc-text">| 10.2 | LEC 18 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-LEC-19-note"><span class="toc-text">| 10.3 | LEC 19 note</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-trap-and-emulate"><span class="toc-text">| 10.3.1 | trap-and-emulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-hardware-support"><span class="toc-text">| 10.3.2 | hardware support</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3-Dune-Safe-User-level-Access-to-Privileged-CPU-Features"><span class="toc-text">| 10.3.3 | Dune: Safe User-level Access to Privileged CPU Features</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-LEC-20-note"><span class="toc-text">| 10.4 | LEC 20 note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-Lab-mmap"><span class="toc-text">| 10.5 | Lab: mmap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Lab-net-%E7%9B%B8%E5%85%B3"><span class="toc-text">| 11 | Lab net 相关</span></a></li></ol>
      </div>
</div>
<style>
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>



        <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="| 0 | 前言"></a>| 0 | 前言</h2><p>MIT 6.S081<del>(6.828?6.1810?)</del> 是 MIT 一门操作系统课程，课程名是 <em>Operating System Engineering</em>（<u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/schedule.html">2020年课程网址</a></u>）这是我的学习笔记，包含课程讲座(LECs), xv6 Book 以及实验(Labs)。</p>
<blockquote>
<p>✅最近一次更新：2024-4-5</p>
</blockquote>
<span id="more"></span>

<p>💻：2018 Macbook Air</p>
<ul>
<li>CPU: 1.6 GHz 双核Intel Core i5</li>
<li>8G 内存</li>
<li>用虚拟机跑的 Ubuntu 22.04 LTS</li>
</ul>
<p>或许是配置问题 <code>usertests</code> 基本都会超时三四十秒，所以延长了一点测试时间。</p>
<blockquote>
<p>笔记中像这样引用的句子为课程中的原文。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv">🔗 我的 Lab 代码链接</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1294282919087964160">🔗【知乎-肖宏辉】MIT6.S081 操作系统工程中文翻译</a></p>
<h2 id="1-Lab-util-相关"><a href="#1-Lab-util-相关" class="headerlink" title="| 1 | Lab util 相关"></a>| 1 | Lab util 相关</h2><h3 id="1-1-LEC-1-amp-Chapter-1-note"><a href="#1-1-LEC-1-amp-Chapter-1-note" class="headerlink" title="| 1.1 | LEC 1  &amp; Chapter 1 note"></a>| 1.1 | LEC 1  &amp; Chapter 1 note</h3><ul>
<li><p>exec</p>
<img alt="图 0" src="/images/image-20240215105112.png" />  
</li>
<li><p>redirect</p>
<img alt="redirect" src="/images/image-20240215105920.png" />  

<ul>
<li><p><code>cat &lt; input.txt</code></p>
<img alt="图 5" src="/images/image-20240215025128.png" /></li>
</ul>
<blockquote>
<p>The <code>2&gt;&amp;1</code> tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1</p>
</blockquote>
</li>
<li><p>pipe</p>
<img alt="图 2" src="/images/image-20240215110731.png" />  

<img alt="图 3" src="/images/image-20240215111726.png" />  

<p>在 <code>fork</code> 之前创建  <code>pipe</code> 然后把 <code>ls</code> 的 <code>stdout(1)</code> 换成 <code>pipefd[1]</code>; <code>grep</code> 的 <code>stdin(0)</code> 换成 <code>pipefd[0]</code> 。</p>
</li>
<li><p>File System</p>
<ul>
<li><p>list</p>
<img alt="图 4" src="/images/image-20240215112407.png" />  
</li>
<li><p>a file</p>
<img alt="图 6" src="/images/image-20240215031307.png" />  

<blockquote>
<p>The file’s <strong>inode and the disk space</strong> holding its content are only <strong>freed</strong> when the file’s link count is zero <strong>and</strong> no file descriptors refer to it.</p>
</blockquote>
</li>
<li><p>cd</p>
<img alt="图 7" src="/images/image-20240215032040.png" /></li>
</ul>
</li>
</ul>
<h3 id="1-2-LEC-2-note"><a href="#1-2-LEC-2-note" class="headerlink" title="| 1.2 | LEC 2 note"></a>| 1.2 | LEC 2 note</h3><ul>
<li><p>Use GNU debugger</p>
<ul>
<li><p>Conditional breakpoints</p>
<blockquote>
<p><code>break &lt;location&gt; if &lt;condition&gt;</code> sets a breakpoint at the specified location, but only breaks if the condition is satisfied.</p>
<p><code>cond &lt;number&gt; &lt;condition&gt;</code> adds a condition on an existing breakpoint.</p>
</blockquote>
</li>
<li><p>Watchpoints</p>
<blockquote>
<p><code>watch &lt;expression&gt;</code> will stop execution whenever the expression’s value changes.</p>
<p><code>watch -l &lt;address&gt;</code> will stop execution whenever the contents of the specified memory address change.</p>
<p>What’s the difference between wa var and wa -l &amp;var?</p>
<p><code>rwatch [-l] &lt;expression&gt;</code> will stop execution whenever the value of the expression is read.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-Lab-Xv6-and-Unix-utilities"><a href="#1-3-Lab-Xv6-and-Unix-utilities" class="headerlink" title="| 1.3 | Lab: Xv6 and Unix utilities"></a>| 1.3 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/util.html">Lab: Xv6 and Unix utilities</a></u></h3><blockquote>
<p>This lab will familiarize you with xv6 and its system calls.</p>
</blockquote>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/591607a62b87f80b279ba7f85bfa7e75f1827af6">Lab 1 代码在这里</a></u></p>
<h4 id="1-3-1-Boot-xv6-easy"><a href="#1-3-1-Boot-xv6-easy" class="headerlink" title="| 1.3.1 | Boot xv6 (easy)"></a>| 1.3.1 | Boot xv6 (easy)</h4><ul>
<li><p><code>sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6</code> 失败</p>
<p>参考下面的手动编译方法编译 qemu</p>
<ul>
<li>补充： <code>sudo apt-get install libpixman-1-dev</code> 安装 pixman devel packag</li>
</ul>
</li>
</ul>
<img alt="图 9" src="/images/image-20240215045015.png" style="zoom:60%" />  

<h4 id="1-3-2-sleep-easy"><a href="#1-3-2-sleep-easy" class="headerlink" title="| 1.3.2 | sleep (easy)"></a>| 1.3.2 | sleep (easy)</h4><img alt="图 10" src="/images/image-20240215075032.png" />  

<h4 id="1-3-3-pingpong-easy"><a href="#1-3-3-pingpong-easy" class="headerlink" title="| 1.3.3 | pingpong (easy)"></a>| 1.3.3 | pingpong (easy)</h4><p>为了阻止父进程在向管道写了数据后立刻把数据读出来，使得子进程不能读到数据，可以在父进程调用 <code>write(pipefds[1], &quot;c&quot;, 1);</code> 后接着调用 <code>sleep</code> 。</p>
<img alt="图 11" src="/images/image-20240215083157.png" />  

<h4 id="1-3-4-primes-moderate-x2F-hard"><a href="#1-3-4-primes-moderate-x2F-hard" class="headerlink" title="| 1.3.4 | primes (moderate)&#x2F;(hard)"></a>| 1.3.4 | primes (moderate)&#x2F;(hard)</h4><img alt="图 12" src="/images/image-20240215100148.png" />  

<h4 id="1-3-5-find-moderate-amp-xargs-moderate"><a href="#1-3-5-find-moderate-amp-xargs-moderate" class="headerlink" title="| 1.3.5 | find (moderate) &amp; xargs (moderate)"></a>| 1.3.5 | find (moderate) &amp; xargs (moderate)</h4><blockquote>
<p>后补</p>
</blockquote>
<h2 id="2-Lab-syscall-相关"><a href="#2-Lab-syscall-相关" class="headerlink" title="| 2 | Lab syscall 相关"></a>| 2 | Lab syscall 相关</h2><h3 id="2-1-Chapter-2-note-amp-LEC-3-note"><a href="#2-1-Chapter-2-note-amp-LEC-3-note" class="headerlink" title="| 2.1 | Chapter 2 note &amp; LEC 3 note"></a>| 2.1 | Chapter 2 note &amp; LEC 3 note</h3><blockquote>
<p>Thus an operating system must fulfill three requirements: <strong>multiplexing</strong>, <strong>isolation</strong>, and <strong>interaction</strong>.</p>
</blockquote>
<p>Multiplexing 多路复用，也就是分时(time-sharing)，防止某个进程持续占有 CPU。</p>
<p>Isolation 隔离，为减少某些不受信任的应用对其他的影响。</p>
<p>Interaction 交互，为实现进程之间的信息交互，实现更复杂的功能。</p>
<h4 id="2-1-1-Abstracting-physical-resources"><a href="#2-1-1-Abstracting-physical-resources" class="headerlink" title="| 2.1.1 | Abstracting physical resources"></a>| 2.1.1 | Abstracting physical resources</h4><blockquote>
<p>To achieve strong <strong>isolation</strong> it’s helpful to forbid applications from directly accessing sensitive hardware resources, and instead to <u>abstract the resources into services.</u></p>
<p>Unix <u>transparently switches hardware CPUs among processes</u>, saving and restor- ing register state as necessary</p>
<p>Many forms of <strong>interaction</strong> among Unix processes occur <u>via file descriptors</u>.</p>
</blockquote>
<h4 id="2-1-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-1-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="| 2.1.2 | User mode, supervisor mode, and system calls"></a>| 2.1.2 | User mode, supervisor mode, and system calls</h4><blockquote>
<p><strong>RISC-V</strong> has three modes in which the CPU can execute instructions: <strong><i>machine mode, supervisor mode, and user mode</i></strong>.</p>
<p>An application can execute only user-mode instructions is said to be running in <i>user space</i>.</p>
<p>The software in supervisor mode can also execute privileged instructions and is said to be running in <i>kernel space</i>.</p>
<p>The software running in <i>kernel space </i>(or in supervisor mode) is called the <i>kernel</i>.</p>
<p>CPUs provide a special instruction that switches the CPU <u>from user mode to supervisor mode</u> and enters the kernel at an entry point specified <u>by the kernel</u>. (RISC-V provides the <code>ecall</code> instruction)</p>
</blockquote>
<h4 id="2-1-3-Kernel-organization"><a href="#2-1-3-Kernel-organization" class="headerlink" title="| 2.1.3 | Kernel organization"></a>| 2.1.3 | Kernel organization</h4><blockquote>
<p><strong>monolithic kernel</strong>: entire operating system resides in the kernel</p>
</blockquote>
<p>在宏内核(monolithie kernel)情况下，内核等于操作系统。</p>
<blockquote>
<p>bad: <u>no isolation</u> within (subsystems)</p>
</blockquote>
<p>微内核(microkernel)暂时不考虑。</p>
<h4 id="2-1-4-Process-overview"><a href="#2-1-4-Process-overview" class="headerlink" title="| 2.1.4 | Process overview"></a>| 2.1.4 | Process overview</h4><blockquote>
<p>The unit of <strong>isolation</strong> in Unix is a <strong>process</strong>.</p>
</blockquote>
<p>隔离包括进程(processes)之间的隔离，以及进程和内核之间的隔离。</p>
<p>进程提供了一个<strong>看上去私有</strong>的内存空间即地址空间(address space)。</p>
<p>地址空间通过页表(<strong>page tables</strong>)实现。</p>
<h4 id="2-1-5-Code-starting-xv6-and-the-first-process"><a href="#2-1-5-Code-starting-xv6-and-the-first-process" class="headerlink" title="| 2.1.5 | Code: starting xv6 and the first process"></a>| 2.1.5 | Code: starting xv6 and the first process</h4><p><code>_entry</code> -&gt; <code>start</code> -&gt; <code>main</code> -&gt; <code>userinit</code> -&gt; <code>/init</code></p>
<h3 id="2-2-Lab-system-calls"><a href="#2-2-Lab-system-calls" class="headerlink" title="| 2.2 | Lab: system calls"></a>| 2.2 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/syscall.html">Lab: system calls</a></u></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sev1n@ubuntu2204 ~/f/6/xv6-labs-2020&gt; ./grade-lab-syscall                                                     syscall!?</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test trace 32 grep == trace 32 grep: OK (1.4s)</span><br><span class="line">== Test trace all grep == trace all grep: OK (1.1s)</span><br><span class="line">== Test trace nothing == trace nothing: OK (0.9s)</span><br><span class="line">== Test trace children == trace children: OK (16.6s)</span><br><span class="line">== Test sysinfotest == sysinfotest: OK (2.8s)</span><br><span class="line">== Test time ==</span><br><span class="line">time: OK</span><br><span class="line">Score: 35/35</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-System-call-tracing-moderate"><a href="#2-2-1-System-call-tracing-moderate" class="headerlink" title="| 2.2.1 | System call tracing (moderate)"></a>| 2.2.1 | System call tracing (moderate)</h4><p>注意 <code>sys_trace</code> 成功时返回值为 0</p>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/591607a62b87f80b279ba7f85bfa7e75f1827af6">这部分代码在这里</a></u> (没注意把 <code>.gdb_history</code> 提交了)</p>
<h4 id="2-2-2-Sysinfo-moderate"><a href="#2-2-2-Sysinfo-moderate" class="headerlink" title="| 2.2.2 | Sysinfo (moderate)"></a>| 2.2.2 | Sysinfo (moderate)</h4><ul>
<li><p>xv6 的内存管理机制</p>
<p>通过单链表 <code>freelist</code> 连接所有闲置的 PAGE，每次从头(<code>kmem-&gt;freelist</code>)存取</p>
</li>
</ul>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/506f6ce82c51384bfd4e010d7080b9d1784c9d03">这部分代码在这里</a></u></p>
<h2 id="3-Lab-pgtbl-相关"><a href="#3-Lab-pgtbl-相关" class="headerlink" title="| 3 | Lab pgtbl 相关"></a>| 3 | Lab pgtbl 相关</h2><h3 id="3-1-Chapter-3-amp-LEC-4-note"><a href="#3-1-Chapter-3-amp-LEC-4-note" class="headerlink" title="| 3.1 | Chapter 3 &amp; LEC 4 note"></a>| 3.1 | Chapter 3 &amp; LEC 4 note</h3><h4 id="3-1-1-Paging-hardware"><a href="#3-1-1-Paging-hardware" class="headerlink" title="| 3.1.1 | Paging hardware"></a>| 3.1.1 | Paging hardware</h4><img alt="图 0" src="/images/image-20240306030218.png" />  

<blockquote>
<p><code>PTE_U</code> controls whether instructions in <u>user mode are allowed to access the page</u>;</p>
</blockquote>
<p><code>satp</code> 寄存器保存 l2 页表的<strong>物理地址</strong></p>
<p>虚拟地址到物理地址的翻译过程：</p>
<ul>
<li>当前进程的 <code>satp</code> 寄存器找到 l2 页表物理地址</li>
<li>通过 l2 的 9 比特(bits 和 2^9&#x3D;512 个 PTE 一一对应)找到对应的 44 比特 PPN。<ul>
<li><code>l2_pte = l2_pgtbl[PX(2, va)]</code></li>
</ul>
</li>
<li>通过 l2 PPN 找到 l1 页表的物理地址。<ul>
<li><code>l1_pgtbl = PTE2PA(l2_pte)</code></li>
</ul>
</li>
<li>通过 l1 的 9 比特找到 l0 页表的物理地址。<ul>
<li><code>l0_pgtbl = PTE2PA(l1_pgtbl[PX(1, va)])</code></li>
</ul>
</li>
<li>通过 l0 的 9 比特找到对应页的物理地址(A)。<ul>
<li><code>l0_pte = l0_pgtbl[PX(0, va)]</code></li>
</ul>
</li>
<li>得到最终物理地址<ul>
<li><code>pa = PTE2PA(l0_pte) | (va &amp; PGSHIFT)</code></li>
</ul>
</li>
</ul>
<p>为什么多级页表可以节省内存？</p>
<ul>
<li>使用多级页表，程序一开始只需要三个页表(3*512 PGSIZE)，l2,l1 页表内都只有一个页表项(pte)，其他空余的位置不需要分配页表项，等需要的时候再分配。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset **within** a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))  <span class="comment">// 向上取整对其一页</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))  <span class="comment">// 向下取整对其</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br><span class="line"><span class="comment">// 只用了这几个 bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">// 12 即 PGSHIFT，10 是因为低 10 bit 是 Flags</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x3FF 10 bits</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="comment">// 即最高有效位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs 0~2^9</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-Kernel-address-space"><a href="#3-1-2-Kernel-address-space" class="headerlink" title="| 3.1.2 | Kernel address space"></a>| 3.1.2 | Kernel address space</h4><img alt="图 1" src="/images/image-20240306080809.png" />  

<h4 id="3-1-3-Code-creating-an-address-space"><a href="#3-1-3-Code-creating-an-address-space" class="headerlink" title="| 3.1.3 | Code: creating an address space"></a>| 3.1.3 | Code: creating an address space</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kinit-&gt;kvminit-&gt;kvminithart-&gt;procinit</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kinit</code> 把内核数据段结束(.data)到定义的 <code>PHYSTOP</code> 之间的地址分页，组织到 <code>freelist</code> 链表里。</li>
<li><code>kvminit</code><ul>
<li>首先调用 <code>kalloc</code> 分配一页 作为内核页表(kernel_pagetable)。</li>
<li>调用 <code>kvmmap</code> 映射上一节(3.1.2)的地址</li>
<li><code>kvmmap</code> 调用 <code>mappages(kernel_pagetable, va, sz, pa, perm)</code></li>
<li><code>mappages</code> 调用 <code>pte = walk(pagetable, a, 1)</code> 把虚拟地址 <code>va</code> 映射到内核页表。</li>
</ul>
</li>
<li><code>kvminithart</code> 设置 <code>satp</code> 寄存器并清空 TLB 缓存。</li>
<li><code>procinit</code><ul>
<li>调用 <code>kvmmap</code> 给 <code>KSTACK</code> 宏计算出来的内核栈虚拟地址映射物理地址。</li>
<li>调用 <code>kvminithart</code></li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li><code>kalloc</code> 分配的一页可以作为一个页表。因为 <code>PAGESIZE</code> 是 4096B 也就是 8*512B，页表项只用了 54 bit 不到 8B，所以是够的。</li>
<li><code>procinit</code> 最后还要再调用一次 <code>kvminithart</code> 因为”当内核修改页表时，它需要通知硬件关于这些变化，以便处理器能够使用最新的页表进行地址转换。” (by chatGPT)。存疑？</li>
</ul>
<h4 id="3-1-4-Code-exec"><a href="#3-1-4-Code-exec" class="headerlink" title="| 3.1.4 | Code: exec"></a>| 3.1.4 | Code: exec</h4><p>把存在文件系统的一个<strong>文件</strong>加载到内存同时初始化<strong>用户地址空间(address space)</strong></p>
<p>在检查完文件格式后 <code>exec</code> 会分配一个新的页表 ，给每个 ELF 段(segment) 分配并加载到内存。</p>
<blockquote>
<p><code>Exec</code> <u><strong>allocates</strong> a <strong>new page table</strong> with no user mappings</u> with <code>proc_pagetable</code>, <u><strong>allocates</strong> memory for each ELF <strong>segment</strong></u> with <code>uvmalloc</code>, and <u><strong>loads</strong> each segment into memory</u> with <code>loadseg</code>. <code>loadseg</code> uses <code>walkaddr</code> to find the physical address of the allocated memory at which to write each page of the ELF segment, and <code>readi</code> to read from the file.</p>
</blockquote>
<p>给用户栈(ustack)分配一页然后初始化。</p>
<blockquote>
<p><code>Exec</code> <strong>copies</strong> the argument strings to the <strong>top</strong> of the stack one at a time, recording the pointers to them in <code>ustack</code>. It places a null pointer at the end of what will be the <code>argv</code> list passed to <code>main</code>. The first three entries in <code>ustack</code> are the <strong>fake return program counter</strong>, <code>argc</code> and <code>argv</code> pointer.</p>
</blockquote>
<p>分配一个 <em>guard page</em> 在 <code>ustack</code> 的上方。</p>
<img alt="图 0" src="/images/image-20240315041134.png" />

<h3 id="3-2-LEC-5-note"><a href="#3-2-LEC-5-note" class="headerlink" title="| 3.2 | LEC 5 note"></a>| 3.2 | LEC 5 note</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reg    | name  | saver  | description</span><br><span class="line">-------+-------+--------+------------</span><br><span class="line">x0     | zero  |        | hardwired zero</span><br><span class="line">x1     | ra    | caller | return address</span><br><span class="line">x2     | sp    | callee | stack pointer</span><br><span class="line">x3     | gp    |        | global pointer</span><br><span class="line">x4     | tp    |        | thread pointer</span><br><span class="line">x5-7   | t0-2  | caller | temporary registers</span><br><span class="line">x8     | s0/fp | callee | saved register / frame pointer</span><br><span class="line">x9     | s1    | callee | saved register</span><br><span class="line">x10-11 | a0-1  | caller | function arguments / return values</span><br><span class="line">x12-17 | a2-7  | caller | function arguments</span><br><span class="line">x18-27 | s2-11 | callee | saved registers</span><br><span class="line">x28-31 | t3-6  | caller | temporary registers</span><br><span class="line">pc     |       |        | program counter</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Lab-page-tables"><a href="#3-3-Lab-page-tables" class="headerlink" title="| 3.3 | Lab: page tables"></a>| 3.3 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/pgtbl.html">Lab: page tables</a></u></h3><img alt="图 1" src="/images/image-20240318031850.png" />

<h4 id="3-3-1-Print-a-page-table-easy"><a href="#3-3-1-Print-a-page-table-easy" class="headerlink" title="| 3.3.1 | Print a page table (easy)"></a>| 3.3.1 | Print a page table (easy)</h4><p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/1e2081b74e7c8ca53f7b61d7f2f2f97fbcd883ff">这部分代码在这里</a></u></p>
<h4 id="3-3-2-A-kernel-page-table-per-process-hard"><a href="#3-3-2-A-kernel-page-table-per-process-hard" class="headerlink" title="| 3.3.2 | A kernel page table per process (hard)"></a>| 3.3.2 | A kernel page table per process (hard)</h4><p>为什么每个进程都需要一个内核页表？</p>
<ul>
<li>用户态页表使得用户态可以直接访问虚拟地址(由硬件来翻译)</li>
<li>但是当陷入内核态时，内核的页表没有用户态的虚拟地址，所以不能直接访问用户虚拟地址</li>
<li>为了访问用户虚拟地址，xv6 通过 <code>walk</code> 函数把来自用户态的虚拟地址转换成内核可操作的物理地址</li>
<li>当每个进程有自己的内核页表时的时候，把 <code>satp</code> 设置成内核页表的地址就可以直接访问用户态虚拟地址了</li>
</ul>
<p>所以 <code>proc</code> 结构体在初始化时，多维护一个 <code>kpagetable</code>，首先映射(map)内核空间，然后当用户页表更新时，同时更新内核页表；在切换进程时也需要切换全局内核页表(调度器内核页表)。</p>
<p>需要注意的几点：</p>
<ul>
<li>每个进程在创建时都需要设置好内核页表，包含一下几点，分配其空间(一页)，映射内核地址空间。<ul>
<li>进程的创建在 <code>allocproc()</code>，它被 <code>userinit()</code> 和 <code>fork()</code> 调用。</li>
</ul>
</li>
<li>每个进程都有内核栈(kstack)，在之前的版本，所有的内核栈都被 <code>procinit</code> 映射到全局的内核页表。现在映射内核栈需要在分配好内核页表之后。</li>
<li>这一节只需要保持 <code>kpagetable</code> 和全局变量<code>kernel_pagetable</code> 一致，所以还要再把内核栈映射到全局 <code>kernel_pagetable</code>，不用同步更新内核页表。</li>
</ul>
<p>释放内核页表(参考 <code>proc_freepagetable</code>)</p>
<ul>
<li>清理叶子结点。</li>
<li>调用 <code>freewalk</code> 释放占用的物理页框。</li>
</ul>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/e908dc35eaa3db6ddbdaa8d6abcc1839aebd2465">这部分代码在这里</a></u></p>
<h4 id="3-3-3-Simplify-copyin-copyinstr-hard"><a href="#3-3-3-Simplify-copyin-copyinstr-hard" class="headerlink" title="| 3.3.3 | Simplify copyin/copyinstr (hard)"></a>| 3.3.3 | Simplify <code>copyin/copyinstr</code> (hard)</h4><p>为了防止用户地址空间和内核地址空间重叠所以需要限制用户虚拟地址上限是 <code>0xC000000</code>。为了内核页表能访问用户态虚拟地址，需要保持内核页表和用户页表在用户地址空间一致。之前的 <code>kernel_pagetable</code> 映射了 <code>CLINT</code>(0x2000000)，如果限制 <code>MAXUVA</code> 是 <code>CLINT</code> 的话通过不了 <code>usertests sbrkmuch</code> 所以可以不用映射 <code>CLINT</code> 。</p>
<p>用户页表的创建&#x2F;更新过程如下：</p>
<ul>
<li><code>proc_pagetable()</code><ul>
<li>调用 <code>uvmcreate()</code> 获得一个物理页框。</li>
<li>然后 <code>mappages()</code> 映射 <code>trampoline</code> 以及 <code>trapframe</code>。</li>
</ul>
</li>
<li><code>fork()</code><ul>
<li>先调用 <code>allocproc()</code> 获得一个基本的用户页表。</li>
<li>然后 <code>uvmcopy()</code> 复制父进程的页表即可。</li>
</ul>
</li>
<li><code>userint()</code><ul>
<li>同样是 <code>allocproc()</code> 起手。</li>
<li>然后调用 <code>uvminit</code> 把 <code>initcode</code> 映射到 <code>va=0</code> 的位置。</li>
</ul>
</li>
<li><code>exec()</code> 见 <a href="#3-1-4-Code-exec">| 3.1.4 |</a></li>
<li><code>sbrk()</code><ul>
<li><code>growproc()</code> 根据传入参数正负调用<code>uvmalloc/uvmdealloc</code>。</li>
<li><code>uvmalloc()</code> 从原来的虚拟地址往上分配页。</li>
<li><code>uvmdealloc()</code> 从原来的虚拟地址往下减少页。</li>
</ul>
</li>
</ul>
<p>内核页表应该<strong>只建立相同映射</strong>，<strong>不再分配和释放物理帧</strong>。</p>
<p>用户页表释放过程:</p>
<ul>
<li><code>freeproc()</code> 在 <code>proc_freepagetable()</code> 的时候也要对内核页表同样操作。</li>
<li><code>exec()</code> 会释放原来的用户页表。</li>
<li>因为有 <code>kstack</code>, <code>kpagetable</code> 应随着进程的创建释放而创建释放。</li>
</ul>
<p>注意：</p>
<ul>
<li><p>限制用户地址空间不超过：</p>
<ul>
<li><p><code>p-&gt;sz</code> 是当前进程占用内存大小，限制它即可。</p>
</li>
<li><p>写 <code>p-&gt;sz</code> 的地方只有两处是用变量赋值的分别是。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec.c:<span class="number">114</span>:<span class="number">3</span>:  p-&gt;sz = sz;</span><br><span class="line">proc.c:<span class="number">264</span>:<span class="number">3</span>:  p-&gt;sz = sz;  <span class="comment">// growproc</span></span><br></pre></td></tr></table></figure>

<p>这两个 <code>sz</code> 都是 <code>uvmalloc()</code> 的返回值，所以在这里限制就可以。</p>
</li>
</ul>
</li>
<li><p>当 <code>exec</code> <code>goto bad</code> 的时候，<code>kpagetable</code> 必须和刚开始一样。</p>
</li>
</ul>
<p><del>梳理完 user pagetable 机制之后终于是清晰了很多，但是 debug 还是痛苦且漫长。做出来之后还是很有成就感(笑)</del></p>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/816f857b41ae59e0379b98e1bba7cffcf393bcd4">这部分代码在这里</a></u></p>
<h2 id="4-Lab-trap-相关"><a href="#4-Lab-trap-相关" class="headerlink" title="| 4 | Lab trap 相关"></a>| 4 | Lab trap 相关</h2><h3 id="4-1-Chapter-4-amp-LEC-6-note"><a href="#4-1-Chapter-4-amp-LEC-6-note" class="headerlink" title="| 4.1 | Chapter 4 &amp; LEC 6 note"></a>| 4.1 | Chapter 4 &amp; LEC 6 note</h3><blockquote>
<p>There are <strong>three</strong> kinds of event which cause the CPU to set aside ordinary execution of instructions and <u>force a transfer of control to special code</u> that handles the event.</p>
</blockquote>
<ul>
<li>system call(<code>ecall</code>)</li>
<li><em>exception</em></li>
<li>device <em>interrupt</em></li>
</ul>
<p><del>不会翻译 <em>trap</em> 就直接写英文了。</u></p>
<p>tarp 应该是 <strong>tansparent</strong>，尤其对于中断，因其随时可能发生。</p>
<blockquote>
<p>While commonality among the three trap types <u>suggests that a kernel could handle all traps with a <strong>single</strong> code path</u>, it turns out to be convenient to have <u>separate assembly vectors and C trap handlers</u> for <strong>three</strong> distinct cases: <u>traps from user space</u>, <u>traps from kernel space</u>, and <u>timer interrupts</u>.</p>
</blockquote>
<h4 id="4-1-1-RISC-V-trap-machinery"><a href="#4-1-1-RISC-V-trap-machinery" class="headerlink" title="| 4.1.1 | RISC-V trap machinery"></a>| 4.1.1 | RISC-V trap machinery</h4><blockquote>
<p>What does the CPU’s “mode” protect?<br>i.e. what does switching mode from user to supervisor <strong>allow</strong>?<br>supervisor can <u>use CPU control registers:</u></p>
<ul>
<li>satp – page table physical address</li>
<li>stvec – ecall jumps here in kernel; points to trampoline</li>
<li>sepc – ecall saves user pc here</li>
<li>sscratch – address of trapframe</li>
<li>scause – a number put by RISC-V that describes the reason for the trap</li>
<li>sstatus: supervisor status register</li>
<li>…..</li>
</ul>
<p>supervisor can <u>use PTEs that have no PTE_U flag</u><br>but supervisor has <strong>no other powers!</strong> e.g.</p>
<ul>
<li><strong>can’t</strong> use addresses that <u>aren’t the in page table</u><br>so kernel has to carefully set things up so it can work</li>
</ul>
</blockquote>
<h4 id="4-1-2-Traps-from-user-space"><a href="#4-1-2-Traps-from-user-space" class="headerlink" title="| 4.1.2 | Traps from user space"></a>| 4.1.2 | Traps from user space</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">preview:</span><br><span class="line">  write()                        write() returns              User</span><br><span class="line">  -----------------------------------------------------------------</span><br><span class="line">  uservec() in trampoline.S      userret() in trampoline.S   Kernel</span><br><span class="line">  usertrap() in trap.c           usertrapret() in trap.c</span><br><span class="line">  syscall() in syscall.c           ^</span><br><span class="line">  sys_write() in sysfile.c      ---|</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ecall</code> did three things:</p>
<ul>
<li>change mode from user to supervisor</li>
<li><u>save <code>pc</code> in <code>sepc</code></u></li>
<li>jump to <code>stvec</code>(the kernel previously set <code>stvec</code>, before jumping to user space)</li>
</ul>
</blockquote>
<ul>
<li><p><code>uservec()</code>:</p>
<ul>
<li>保存 32 个用户寄存器(用于恢复)</li>
<li>切换到内核页表, 内核栈</li>
<li>跳(jump)到 <code>usertrap()</code></li>
</ul>
</li>
<li><p><code>usertrap()</code></p>
<ul>
<li>修改 <code>stvec = kernelvec</code></li>
<li>根据 <code>scause</code> 调用不同的处理函数(handler)</li>
<li><code>usertrapret()</code></li>
</ul>
</li>
<li><p><code>usertrapret()</code></p>
<ul>
<li>设置 <code>stvec = uservec</code></li>
<li>在 <em>trapframe</em> 中保存以下未在 <code>tampline.S</code> 保存的值, 也是初始化新的 <em>trapframe</em> 的地方:<ul>
<li><code>kpagetable</code> 所以 <code>uservec</code> 可以切换</li>
<li><code>kstack</code> 所以 <code>uservec</code> 可以切换</li>
<li><code>hartid</code>, 可能被其他 CPU 调度要更新</li>
<li><code>usertrap</code> 地址，让 <code>uservec</code> 找得到</li>
</ul>
</li>
<li>设置 <code>sstatus</code> 寄存器</li>
<li><u>设置 <code>sepc = trapframe-&gt;epc</code></u></li>
</ul>
</li>
<li><p><code>userret()</code></p>
<ul>
<li>切换 <code>satp</code> &#x3D; 用户页表</li>
<li>恢复 32 个 用户寄存器</li>
<li><code>sret</code></li>
</ul>
</li>
<li><p><code>sret</code></p>
<ul>
<li>set <code>sstatus</code> “previous mode” bit to user</li>
<li>恢复 <code>pc</code> &#x3D; <code>sepc</code></li>
</ul>
</li>
</ul>
<p>中断的开与关：</p>
<blockquote>
<p>后补</p>
</blockquote>
<h4 id="4-1-3-Traps-from-kernel-space"><a href="#4-1-3-Traps-from-kernel-space" class="headerlink" title="| 4.1.3 | Traps from kernel space"></a>| 4.1.3 | Traps from kernel space</h4><ul>
<li><p><code>kernelvec</code></p>
<p>保存 31 个寄存器到内核栈</p>
<p>调用 <code>kerneltrap</code></p>
<p>恢复寄存器</p>
<p><code>sret</code></p>
</li>
</ul>
<h3 id="4-2-Lab-traps"><a href="#4-2-Lab-traps" class="headerlink" title="| 4.2 | Lab: traps"></a>| 4.2 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/traps.html">Lab: traps</a></u></h3><img alt="图 2" src="/images/image-20240320063502.png" />

<h4 id="4-2-1-RISC-V-assembly-easy"><a href="#4-2-1-RISC-V-assembly-easy" class="headerlink" title="| 4.2.1 | RISC-V assembly (easy)"></a>| 4.2.1 | RISC-V assembly (easy)</h4><ol>
<li><p><code>a0~a7</code>, <code>a2</code> holds 13 when calling <code>printf</code> in main.</p>
</li>
<li><p><code>f</code> and <code>g</code> is called in compiler.</p>
</li>
<li><p><code>printf</code> is located at <code>0x628</code></p>
</li>
<li><p><code>ra</code> is 0x38</p>
</li>
<li><p>out put is “HE110 Worid”, if big-endian <code>i = 0x726c6400</code>. <code>57616</code> need not to be changed.</p>
</li>
<li><p>after “y&#x3D;”, it will print <code>(int)$a2</code>, because the 2nd arguement of format strings is <code>a2</code>.</p>
</li>
</ol>
<h4 id="4-2-2-Backtrace-moderate"><a href="#4-2-2-Backtrace-moderate" class="headerlink" title="| 4.2.2 | Backtrace (moderate)"></a>| 4.2.2 | Backtrace (moderate)</h4><p><del>提交记录有点乱，就直接贴 diff 了</del></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/defs.h b/kernel/defs.h</span></span><br><span class="line"><span class="comment">index 4b9bbc0..137c786 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/defs.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/defs.h</span></span><br><span class="line"><span class="meta">@@ -80,6 +80,7 @@</span> int             pipewrite(struct pipe*, uint64, int);</span><br><span class="line"> void            printf(char*, ...);</span><br><span class="line"> void            panic(char*) __attribute__((noreturn));</span><br><span class="line"> void            printfinit(void);</span><br><span class="line"><span class="addition">+void            backtrace(void);</span></span><br><span class="line"></span><br><span class="line"> // proc.c</span><br><span class="line"> int             cpuid(void);</span><br><span class="line"><span class="comment">diff --git a/kernel/printf.c b/kernel/printf.c</span></span><br><span class="line"><span class="comment">index e1347de..e9e1ccc 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/printf.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/printf.c</span></span><br><span class="line"><span class="meta">@@ -132,3 +132,15 @@</span> printfinit(void)</span><br><span class="line">   initlock(&amp;pr.lock, &quot;pr&quot;);</span><br><span class="line">   pr.locking = 1;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void backtrace() &#123;</span></span><br><span class="line"><span class="addition">+  printf(&quot;backtrace:\n&quot;);</span></span><br><span class="line"><span class="addition">+  uint64 currfp = r_fp();</span></span><br><span class="line"><span class="addition">+  uint64 stack_top = PGROUNDUP(currfp);</span></span><br><span class="line"><span class="addition">+  while(currfp &lt;= stack_top) &#123;</span></span><br><span class="line"><span class="addition">+    printf(&quot;%p\n&quot;, *(uint64*)(currfp-8));</span></span><br><span class="line"><span class="addition">+    currfp = *(uint64*)(currfp-0x10);</span></span><br><span class="line"><span class="addition">+    if(*(uint64*)(currfp-8) &lt;= PLIC)</span></span><br><span class="line"><span class="addition">+      break;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="comment">diff --git a/kernel/riscv.h b/kernel/riscv.h</span></span><br><span class="line"><span class="comment">index 0aec003..7a443e9 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/riscv.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/riscv.h</span></span><br><span class="line"><span class="meta">@@ -311,6 +311,14 @@</span> r_ra()</span><br><span class="line">   return x;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+static inline uint64</span></span><br><span class="line"><span class="addition">+r_fp()</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  uint64 x;</span></span><br><span class="line"><span class="addition">+  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span></span><br><span class="line"><span class="addition">+  return x;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // flush the TLB.</span><br><span class="line"> static inline void</span><br><span class="line"> sfence_vma()</span><br><span class="line"><span class="comment">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">index e8bcda9..fd19d2a 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/sysproc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/sysproc.c</span></span><br><span class="line"><span class="meta">@@ -70,6 +70,7 @@</span> sys_sleep(void)</span><br><span class="line">     sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">   &#125;</span><br><span class="line">   release(&amp;tickslock);</span><br><span class="line"><span class="addition">+  backtrace();</span></span><br><span class="line">   return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-Alarm-hard"><a href="#4-2-3-Alarm-hard" class="headerlink" title="| 4.2.3 | Alarm (hard)"></a>| 4.2.3 | Alarm (hard)</h4><p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/85c1f6989b438b8d0d2ec2092c9ae7d182fe37cd">这部分代码在这里</a></u></p>
<h2 id="5-Lab-lazy-相关"><a href="#5-Lab-lazy-相关" class="headerlink" title="| 5 | Lab lazy 相关"></a>| 5 | Lab lazy 相关</h2><h3 id="5-1-Chapter-4-6-amp-LEC-8-note"><a href="#5-1-Chapter-4-6-amp-LEC-8-note" class="headerlink" title="| 5.1 | Chapter 4.6 &amp; LEC 8 note"></a>| 5.1 | Chapter 4.6 &amp; LEC 8 note</h3><blockquote>
<p>Key idea: <u>change page tables on page fault</u>, update page table instead of panic and <strong>restart</strong> instruction.</p>
</blockquote>
<blockquote>
<p><strong>Information</strong> we might need at page fault to do something interesting:</p>
<ol>
<li>The virtual address that caused the fault<br> See <code>stval</code> register; page faults set it to the fault address</li>
<li>The type of violation that caused the fault<br> See <code>scause</code> register value (instruction, load, and Store page fault)</li>
<li>The instruction and mode where the fault occurred</li>
</ol>
<ul>
<li>User IP: <code>tf-&gt;epc</code></li>
<li>U&#x2F;K mode: implicit in usertrap&#x2F;kerneltrap</li>
</ul>
</blockquote>
<h4 id="5-1-1-Lazy-Allocation"><a href="#5-1-1-Lazy-Allocation" class="headerlink" title="| 5.1.1 | Lazy Allocation"></a>| 5.1.1 | Lazy Allocation</h4><blockquote>
<p><code>sbrk</code> allocates memory that may <strong>never</strong> be used.</p>
</blockquote>
<blockquote>
<p>plan: allocate physical memory when application needs it</p>
<ul>
<li>Adjust <code>p-&gt;sz</code> on <code>sbrk</code>, but don’t allocate.</li>
<li>When application uses that memory, it will result in page fault.</li>
<li>On pagefault allocate memory resume at the fault instruction.</li>
</ul>
</blockquote>
<p>除此以外，在 <code>unmap</code> 的时候，对延迟分配(<em>lazy allocation</em>) 还未分配的内存应该不处理，继续循环。</p>
<h4 id="5-1-2-Copy-On-Write-COW-fork"><a href="#5-1-2-Copy-On-Write-COW-fork" class="headerlink" title="| 5.1.2 | Copy-On-Write (COW) fork"></a>| 5.1.2 | Copy-On-Write (COW) fork</h4><blockquote>
<p><a href="#6-Lab-cow-%E7%9B%B8%E5%85%B3">| 6.1 |</a></p>
</blockquote>
<h4 id="5-1-3-其他"><a href="#5-1-3-其他" class="headerlink" title="| 5.1.3 | 其他"></a>| 5.1.3 | 其他</h4><ul>
<li><p>Zero Fill Page</p>
<p><code>bss</code> 段(segment) 最开始都是 0，所以可把 bss 虚拟地址先映射到同一页且只读。</p>
<p>当向 bss 写时触发缺页错误(page fault)，然后再该映射虚拟地址对应页。</p>
</li>
<li><p>Demand Paging</p>
</li>
</ul>
<blockquote>
<p>idea: load pages from the file on demand.</p>
<ul>
<li>allocate page table entries, but mark them on-demand.</li>
<li>on fault, read the page in from the file and update page table entry.</li>
<li>need to keep some meta information(Virtual Memoroy Area) about where a page is located on disk.</li>
</ul>
</blockquote>
<ul>
<li>Paging From Disk</li>
</ul>
<blockquote>
<p>idea: store less-frequently used parts of the address space on disk.  page-in and page-out pages of the address address space transparently.</p>
</blockquote>
<ul>
<li><p>Memory-Mapped Files</p>
<p>放在 mmap lab 讨论</p>
</li>
</ul>
<h3 id="5-2-Chapter-5-amp-LEC-9-note"><a href="#5-2-Chapter-5-amp-LEC-9-note" class="headerlink" title="| 5.2 | Chapter 5 &amp; LEC 9 note"></a>| 5.2 | Chapter 5 &amp; LEC 9 note</h3><ul>
<li><p><em>interrupts</em></p>
<blockquote>
<p>the interrupt tells the kernel the <strong>device hardware</strong> wants attention.</p>
</blockquote>
<blockquote>
<p>new issues:</p>
<ul>
<li>asynchronous: between <strong>running process</strong> and <strong>interrupt handler</strong></li>
<li>concurrency: <strong>device</strong> and <strong>process</strong> run in parallel</li>
<li>programming devices: device can be difficult to program</li>
</ul>
</blockquote>
</li>
<li><p>中断的来源</p>
<p>device -&gt; PLIC(Platform Level Interupt Control) -&gt; CPU</p>
<p>内核通过对 PLIC 编程灵活处理中断。</p>
</li>
<li><p>驱动(<em>driver</em>) 负责管理特定的设备：</p>
<blockquote>
<ul>
<li><p>configures the <strong>device hardware</strong>.</p>
</li>
<li><p>tells the device to perform <strong>operations</strong>.</p>
</li>
<li><p>handles the resulting <strong>interrupts</strong>.</p>
</li>
<li><p>interacts with <strong>processes</strong> that may be waiting for I&#x2F;O from the device.</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>Many <strong>device drivers</strong> execute code in two contexts:</p>
<ul>
<li>a top half that runs in a process’s kernel thread <u>called via system calls</u>.</li>
<li>a bottom half that executes at interrupt time as interrupt handler <u>handling device interupt</u>.</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="5-2-1-Code-Console-input-x2F-output"><a href="#5-2-1-Code-Console-input-x2F-output" class="headerlink" title="| 5.2.1 | Code: Console input&#x2F;output"></a>| 5.2.1 | Code: Console input&#x2F;output</h4><p>当 xv6 启动时，<code>$</code> 是如何被打印到屏幕？</p>
<p>当用户在键盘敲下 <code>ls\n</code> 时，屏幕是如何显示 <code>ls</code> 以及 <code>ls</code> 执行的内容的？</p>
<p>涉及 <code>console/uart</code> 的梳理，后补</p>
<h4 id="5-2-2-Timer-interrupts"><a href="#5-2-2-Timer-interrupts" class="headerlink" title="| 5.2.2 | Timer interrupts"></a>| 5.2.2 | Timer interrupts</h4><p>涉及 <code>mtvec/timervev/CLINT</code> 后补</p>
<h3 id="5-3-Lab-xv6-lazy-page-allocation"><a href="#5-3-Lab-xv6-lazy-page-allocation" class="headerlink" title="| 5.3 | Lab: xv6 lazy page allocation"></a>| 5.3 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/lazy.html">Lab: xv6 lazy page allocation</a></u></h3><img alt="图 3" src="/images/image-20240321075130.png" />  

<img alt="图 4" src="/images/image-20240321075151.png" />  

<h4 id="5-3-1-Lazy-allocation-moderate-amp-amp-Lazytests-and-Usertests-moderate"><a href="#5-3-1-Lazy-allocation-moderate-amp-amp-Lazytests-and-Usertests-moderate" class="headerlink" title="| 5.3.1 | Lazy allocation (moderate) &amp;&amp; Lazytests and Usertests (moderate)"></a>| 5.3.1 | Lazy allocation (moderate) &amp;&amp; Lazytests and Usertests (moderate)</h4><ul>
<li><p><code>sbrk()</code> 不分配物理内存，只修改 <code>p-&gt;sz</code></p>
</li>
<li><p>什么时候分配：</p>
<ul>
<li>用户访问时触发用户触发缺页异常时(usertrap-&gt;page fault)，再分配</li>
<li>用户读写 <code>sbrk()</code> 返回的地址时，由于 xv6 是软件层面 <code>pa = walkaddr(va)</code>，所以 此时也需要分配。</li>
</ul>
</li>
<li><p>注意 ：</p>
<ul>
<li><code>va = p-&gt;sz</code> 的时候是非法的。</li>
<li>如果 <code>sbrk(n) &lt; 0</code>, 需要 <code>sbrk()</code> 释放(unmap) 参考 <code>uvmdealloc()</code>。否则 <code>p-&gt;sz</code> 减小后，上面的虚拟地址 没有 unmap 且已经丢失。</li>
</ul>
</li>
</ul>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/80e58eb55b4417978ef982dc2fac847ae3c29b7b">这部分代码在这里</a></u></p>
<h2 id="6-Lab-cow-相关"><a href="#6-Lab-cow-相关" class="headerlink" title="| 6 | Lab cow 相关"></a>| 6 | Lab cow 相关</h2><blockquote>
<p>The goal of copy-on-write (COW) fork() is to <u>defer allocating and copying physical memory pages</u> for the child until the copies are <strong>actually needed</strong>, if ever.</p>
</blockquote>
<ul>
<li><code>uvmcopy()</code><ul>
<li><code>walk()</code> 父进程的页表， <code>*pte &amp;= ~PTE_W</code>,<code>*pte |= PTE_C</code></li>
<li>映射到子进程的页表, 引用次数增加(reference count ++);</li>
</ul>
</li>
<li><code>usertrap()</code><ul>
<li>在缺页异常的时候，识别出 COW 页。</li>
<li>分配物理内存, 分配失败则杀死(kill)。</li>
<li>复制原数据</li>
<li>修改页表项(PTE) 指向新的物理帧且可写，原页的 <code>reference count--</code></li>
<li>重新执行</li>
</ul>
</li>
<li><code>proc_freepagetable()</code><ul>
<li>如果是 COW 页，<code>--reference count == 0</code> 则 释放</li>
</ul>
</li>
<li><code>reference count</code> 如何实现<ul>
<li>NPROC &#x3D; 64，小于 0xff</li>
<li>计算 <code>freerange()</code> 创建了多少页，然后根据该数量减去内存(见下面的 <code>kalloc.c-kinit()</code>)。</li>
<li><code>kvmmap()</code> 的时候不应该设置 <code>ref count</code>，因为其是表示当前页被用户页表引用的数量。</li>
<li><code>kalloc()</code> 时 设置 <code>cnt = 0</code></li>
<li><code>mappages()</code> 的时候，<code>cnt++</code></li>
<li><code>uvmunmap()</code> 且 do_free 时 <code>cnt--</code></li>
<li><code>cnt==1</code> 则修改 pte 即可。</li>
</ul>
</li>
<li><code>copyout()</code><ul>
<li>和 <code>usertap()</code> 类似操作</li>
</ul>
</li>
</ul>
<h3 id="6-1-Lab-Copy-on-Write-Fork-for-xv6"><a href="#6-1-Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="| 6.1 | Lab: Copy-on-Write Fork for xv6"></a>| 6.1 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/cow.html">Lab: Copy-on-Write Fork for xv6</a></u></h3><img alt="图 7" src="/images/image-20240324042818.png" />  

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/defs.h b/kernel/defs.h</span></span><br><span class="line"><span class="comment">index 4b9bbc0..234b90d 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/defs.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/defs.h</span></span><br><span class="line"><span class="meta">@@ -63,6 +63,9 @@</span> void            ramdiskrw(struct buf*);</span><br><span class="line"> void*           kalloc(void);</span><br><span class="line"> void            kfree(void *);</span><br><span class="line"> void            kinit(void);</span><br><span class="line"><span class="addition">+void            inc_ref_cnt(uint64);</span></span><br><span class="line"><span class="addition">+uint8           get_ref_cnt(uint64);</span></span><br><span class="line"><span class="addition">+uint8           dec_ref_cnt(uint64);</span></span><br><span class="line"></span><br><span class="line"> // log.c</span><br><span class="line"> void            initlog(int, struct superblock*);</span><br><span class="line"><span class="meta">@@ -167,11 +170,13 @@</span> int             uvmcopy(pagetable_t, pagetable_t, uint64);</span><br><span class="line"> void            uvmfree(pagetable_t, uint64);</span><br><span class="line"> void            uvmunmap(pagetable_t, uint64, uint64, int);</span><br><span class="line"> void            uvmclear(pagetable_t, uint64);</span><br><span class="line"><span class="addition">+pte_t*          walkpte(pagetable_t pagetable, uint64 va);</span></span><br><span class="line"> uint64          walkaddr(pagetable_t, uint64);</span><br><span class="line"> int             copyout(pagetable_t, uint64, char *, uint64);</span><br><span class="line"> int             copyin(pagetable_t, char *, uint64, uint64);</span><br><span class="line"> int             copyinstr(pagetable_t, char *, uint64, uint64);</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // plic.c</span><br><span class="line"> void            plicinit(void);</span><br><span class="line"> void            plicinithart(void);</span><br><span class="line"><span class="comment">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span></span><br><span class="line"><span class="comment">index fa6a0ac..8234080 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/kalloc.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/kalloc.c</span></span><br><span class="line"><span class="meta">@@ -14,6 +14,8 @@</span> void freerange(void *pa_start, void *pa_end);</span><br><span class="line"> extern char end[]; // first address after kernel.</span><br><span class="line">                    // defined by kernel.ld.</span><br><span class="line"></span><br><span class="line"><span class="addition">+uint8* phy_ref_cnt;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> struct run &#123;</span><br><span class="line">   struct run *next;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="meta">@@ -23,11 +25,42 @@</span> struct &#123;</span><br><span class="line">   struct run *freelist;</span><br><span class="line"> &#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="addition">+void inc_ref_cnt(uint64 pa) &#123;</span></span><br><span class="line"><span class="addition">+  acquire(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  if(pa &gt;= (uint64)end &amp;&amp; pa &lt; PHYSTOP)</span></span><br><span class="line"><span class="addition">+    phy_ref_cnt[(pa-(uint64)end)&gt;&gt;12]++;</span></span><br><span class="line"><span class="addition">+  release(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+uint8 dec_ref_cnt(uint64 pa) &#123;</span></span><br><span class="line"><span class="addition">+  uint8 result=0;</span></span><br><span class="line"><span class="addition">+  if(get_ref_cnt(pa) == 0)</span></span><br><span class="line"><span class="addition">+    panic(&quot;dec_ref_cnt&quot;);</span></span><br><span class="line"><span class="addition">+  acquire(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  result = --phy_ref_cnt[(pa-(uint64)end)&gt;&gt;12]; // called by uvmunmap pa is in range</span></span><br><span class="line"><span class="addition">+  release(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  return result;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+uint8 get_ref_cnt(uint64 pa) &#123;</span></span><br><span class="line"><span class="addition">+  uint8 result = 1;</span></span><br><span class="line"><span class="addition">+  acquire(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  if(pa &gt;= (uint64)end &amp;&amp; pa &lt; PHYSTOP)</span></span><br><span class="line"><span class="addition">+    result = phy_ref_cnt[(pa-(uint64)end)&gt;&gt;12];</span></span><br><span class="line"><span class="addition">+  release(&amp;kmem.lock);</span></span><br><span class="line"><span class="addition">+  return result;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> void</span><br><span class="line"> kinit()</span><br><span class="line"> &#123;</span><br><span class="line">   initlock(&amp;kmem.lock, &quot;kmem&quot;);</span><br><span class="line"><span class="deletion">-  freerange(end, (void*)PHYSTOP);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // caculate the need of ref counts</span></span><br><span class="line"><span class="addition">+  int bytes = (PHYSTOP-PGROUNDUP((uint64)end))&gt;&gt;12;</span></span><br><span class="line"><span class="addition">+  phy_ref_cnt = (uint8*)end;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  freerange((void*)end+bytes, (void*)PHYSTOP);</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void</span><br><span class="line"><span class="meta">@@ -72,8 +105,10 @@</span> kalloc(void)</span><br><span class="line"></span><br><span class="line">   acquire(&amp;kmem.lock);</span><br><span class="line">   r = kmem.freelist;</span><br><span class="line"><span class="deletion">-  if(r)</span></span><br><span class="line"><span class="addition">+  if(r) &#123;</span></span><br><span class="line">     kmem.freelist = r-&gt;next;</span><br><span class="line"><span class="addition">+    phy_ref_cnt[((uint64)r-(uint64)end)&gt;&gt;12] = 0;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">   release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">   if(r)</span><br><span class="line"><span class="comment">diff --git a/kernel/riscv.h b/kernel/riscv.h</span></span><br><span class="line"><span class="comment">index 0aec003..7b5db8a 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/riscv.h</span></span><br><span class="line"><span class="comment">+++ b/kernel/riscv.h</span></span><br><span class="line"><span class="meta">@@ -331,6 +331,7 @@</span> sfence_vma()</span><br><span class="line"> #define PTE_W (1L &lt;&lt; 2)</span><br><span class="line"> #define PTE_X (1L &lt;&lt; 3)</span><br><span class="line"> #define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span><br><span class="line"><span class="addition">+#define PTE_C (1L &lt;&lt; 8)</span></span><br><span class="line"></span><br><span class="line"> // shift a physical address to the right place for a PTE.</span><br><span class="line"> #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span><br><span class="line"><span class="comment">diff --git a/kernel/trap.c b/kernel/trap.c</span></span><br><span class="line"><span class="comment">index a63249e..e08ee89 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/trap.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/trap.c</span></span><br><span class="line"><span class="meta">@@ -10,6 +10,7 @@</span> struct spinlock tickslock;</span><br><span class="line"> uint ticks;</span><br><span class="line"></span><br><span class="line"> extern char trampoline[], uservec[], userret[];</span><br><span class="line"><span class="addition">+extern uint8* phy_ref_cnt;</span></span><br><span class="line"></span><br><span class="line"> // in kernelvec.S, calls kerneltrap().</span><br><span class="line"> void kernelvec();</span><br><span class="line"><span class="meta">@@ -65,6 +66,34 @@</span> usertrap(void)</span><br><span class="line">     intr_on();</span><br><span class="line"></span><br><span class="line">     syscall();</span><br><span class="line"><span class="addition">+  &#125; else if(r_scause() == 15) &#123;</span></span><br><span class="line"><span class="addition">+    // write page fault</span></span><br><span class="line"><span class="addition">+    uint64 val = r_stval();</span></span><br><span class="line"><span class="addition">+    if(val &gt;= p-&gt;sz) &#123;// check va</span></span><br><span class="line"><span class="addition">+      p-&gt;killed = 1;</span></span><br><span class="line"><span class="addition">+      exit(-1);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    pte_t *pte = walkpte(p-&gt;pagetable, val);</span></span><br><span class="line"><span class="addition">+    if(pte == 0 || !(*pte &amp; PTE_C)) &#123;</span></span><br><span class="line"><span class="addition">+      p-&gt;killed = 1;</span></span><br><span class="line"><span class="addition">+      exit(-1);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    uint64 pa = PTE2PA(*pte);</span></span><br><span class="line"><span class="addition">+    if (get_ref_cnt(pa) == 1) &#123;</span></span><br><span class="line"><span class="addition">+      *pte |= PTE_W;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    else &#123;</span></span><br><span class="line"><span class="addition">+      char* mem = (char*)kalloc();</span></span><br><span class="line"><span class="addition">+      if(mem == 0) &#123;</span></span><br><span class="line"><span class="addition">+        p-&gt;killed = 1;</span></span><br><span class="line"><span class="addition">+        exit(-1);</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+      memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line"><span class="addition">+      uvmunmap(p-&gt;pagetable, PGROUNDDOWN(val), 1, 1);</span></span><br><span class="line"><span class="addition">+      mappages(p-&gt;pagetable, PGROUNDDOWN(val), PGSIZE, (uint64)mem, PTE_X|PTE_W|PTE_U|PTE_R);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   &#125; else if((which_dev = devintr()) != 0)&#123;</span><br><span class="line">     // ok</span><br><span class="line">   &#125; else &#123;</span><br><span class="line"><span class="comment">diff --git a/kernel/vm.c b/kernel/vm.c</span></span><br><span class="line"><span class="comment">index bccb405..85c7424 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/vm.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/vm.c</span></span><br><span class="line"><span class="meta">@@ -111,14 +111,46 @@</span> walkaddr(pagetable_t pagetable, uint64 va)</span><br><span class="line">   return pa;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+pte_t* walkpte(pagetable_t pagetable, uint64 va) &#123;</span></span><br><span class="line"><span class="addition">+  pte_t *pte;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if(va &gt;= MAXVA)</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  pte = walk(pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+  if(pte == 0)</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  if((*pte &amp; PTE_V) == 0)</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  if((*pte &amp; PTE_U) == 0)</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  return pte;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // add a mapping to the kernel page table.</span><br><span class="line"> // only used when booting.</span><br><span class="line"> // does not flush TLB or enable paging.</span><br><span class="line"> void</span><br><span class="line"> kvmmap(uint64 va, uint64 pa, uint64 sz, int perm)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-  if(mappages(kernel_pagetable, va, sz, pa, perm) != 0)</span></span><br><span class="line"><span class="deletion">-    panic(&quot;kvmmap&quot;);</span></span><br><span class="line"><span class="addition">+  // kvmmap should not increase ref cnt</span></span><br><span class="line"><span class="addition">+  uint64 a, last;</span></span><br><span class="line"><span class="addition">+  pte_t *pte;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  a = PGROUNDDOWN(va);</span></span><br><span class="line"><span class="addition">+  last = PGROUNDDOWN(va + sz - 1);</span></span><br><span class="line"><span class="addition">+  for(;;)&#123;</span></span><br><span class="line"><span class="addition">+    if((pte = walk(kernel_pagetable, a, 1)) == 0)</span></span><br><span class="line"><span class="addition">+      panic(&quot;kvmmap&quot;);</span></span><br><span class="line"><span class="addition">+    if(*pte &amp; PTE_V)</span></span><br><span class="line"><span class="addition">+      panic(&quot;remap&quot;);</span></span><br><span class="line"><span class="addition">+    *pte = PA2PTE(pa) | perm | PTE_V;</span></span><br><span class="line"><span class="addition">+    if(a == last)</span></span><br><span class="line"><span class="addition">+      break;</span></span><br><span class="line"><span class="addition">+    a += PGSIZE;</span></span><br><span class="line"><span class="addition">+    pa += PGSIZE;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // translate a kernel virtual address to</span><br><span class="line"><span class="meta">@@ -159,6 +191,7 @@</span> mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</span><br><span class="line">     if(*pte &amp; PTE_V)</span><br><span class="line">       panic(&quot;remap&quot;);</span><br><span class="line">     *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line"><span class="addition">+    inc_ref_cnt(pa);</span></span><br><span class="line">     if(a == last)</span><br><span class="line">       break;</span><br><span class="line">     a += PGSIZE;</span><br><span class="line"><span class="meta">@@ -188,7 +221,8 @@</span> uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)</span><br><span class="line">       panic(&quot;uvmunmap: not a leaf&quot;);</span><br><span class="line">     if(do_free)&#123;</span><br><span class="line">       uint64 pa = PTE2PA(*pte);</span><br><span class="line"><span class="deletion">-      kfree((void*)pa);</span></span><br><span class="line"><span class="addition">+      if(!dec_ref_cnt(pa))</span></span><br><span class="line"><span class="addition">+        kfree((void*)pa);</span></span><br><span class="line">     &#125;</span><br><span class="line">     *pte = 0;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@@ -311,7 +345,6 @@</span> uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span><br><span class="line">   pte_t *pte;</span><br><span class="line">   uint64 pa, i;</span><br><span class="line">   uint flags;</span><br><span class="line"><span class="deletion">-  char *mem;</span></span><br><span class="line"></span><br><span class="line">   for(i = 0; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">     if((pte = walk(old, i, 0)) == 0)</span><br><span class="line"><span class="meta">@@ -319,14 +352,11 @@</span> uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span><br><span class="line">     if((*pte &amp; PTE_V) == 0)</span><br><span class="line">       panic(&quot;uvmcopy: page not present&quot;);</span><br><span class="line">     pa = PTE2PA(*pte);</span><br><span class="line"><span class="addition">+    *pte = *pte | PTE_C;</span></span><br><span class="line"><span class="addition">+    *pte = *pte &amp; ~PTE_W;</span></span><br><span class="line">     flags = PTE_FLAGS(*pte);</span><br><span class="line"><span class="deletion">-    if((mem = kalloc()) == 0)</span></span><br><span class="line"><span class="deletion">-      goto err;</span></span><br><span class="line"><span class="deletion">-    memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line"><span class="deletion">-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span></span><br><span class="line"><span class="deletion">-      kfree(mem);</span></span><br><span class="line"><span class="addition">+    if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0)</span></span><br><span class="line">       goto err;</span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -355,15 +385,35 @@</span> int</span><br><span class="line"> copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</span><br><span class="line"> &#123;</span><br><span class="line">   uint64 n, va0, pa0;</span><br><span class="line"><span class="addition">+  pte_t *pte;</span></span><br><span class="line"></span><br><span class="line">   while(len &gt; 0)&#123;</span><br><span class="line">     va0 = PGROUNDDOWN(dstva);</span><br><span class="line"><span class="deletion">-    pa0 = walkaddr(pagetable, va0);</span></span><br><span class="line"><span class="deletion">-    if(pa0 == 0)</span></span><br><span class="line"><span class="addition">+    pte = walkpte(pagetable, va0);</span></span><br><span class="line"><span class="addition">+    if(pte == 0)</span></span><br><span class="line">       return -1;</span><br><span class="line"><span class="addition">+    pa0 = PTE2PA(*pte);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    if((*pte &amp; PTE_C) &amp;&amp; !(*pte&amp;PTE_W)) &#123;</span></span><br><span class="line"><span class="addition">+      // dealing with COW page</span></span><br><span class="line"><span class="addition">+      if (get_ref_cnt(pa0) == 1) &#123;</span></span><br><span class="line"><span class="addition">+        *pte |= PTE_W;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+      else &#123;</span></span><br><span class="line"><span class="addition">+        char* mem = (char*)kalloc();</span></span><br><span class="line"><span class="addition">+        if(mem == 0) &#123;</span></span><br><span class="line"><span class="addition">+          return -1;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        memmove(mem, (char*)pa0, PGSIZE);</span></span><br><span class="line"><span class="addition">+        uvmunmap(pagetable, va0, 1, 1);</span></span><br><span class="line"><span class="addition">+        mappages(pagetable, va0, PGSIZE, (uint64)mem, PTE_X|PTE_W|PTE_U|PTE_R);</span></span><br><span class="line"><span class="addition">+        pa0 = (uint64)mem;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     n = PGSIZE - (dstva - va0);</span><br><span class="line">     if(n &gt; len)</span><br><span class="line"><span class="deletion">-      n = len;</span></span><br><span class="line"><span class="addition">+      n = len;  // dealing one page a time</span></span><br><span class="line">     memmove((void *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">     len -= n;</span><br></pre></td></tr></table></figure>

<h2 id="7-Lab-thread-相关"><a href="#7-Lab-thread-相关" class="headerlink" title="| 7 | Lab thread 相关"></a>| 7 | Lab thread 相关</h2><h3 id="7-1-Chapter-6-amp-LEC-10-note"><a href="#7-1-Chapter-6-amp-LEC-10-note" class="headerlink" title="| 7.1 | Chapter 6 &amp; LEC 10 note"></a>| 7.1 | Chapter 6 &amp; LEC 10 note</h3><ul>
<li>concurrency problems - race conditions</li>
<li>broken acquire - 使用硬件提供的原子操作(test&amp;set …)</li>
<li>lock problems - performance&#x2F;deadlock</li>
<li>mem ordering</li>
<li>sleep lock<ul>
<li>为什么 sleep lock 不用关闭中断</li>
</ul>
</li>
</ul>
<!-- #### | 7.1.1 | Code: Locks & Using locks

#### | 7.1.2 | Deadlock and lock ordering

#### | 7.1.3 | Sleep locks -->

<h3 id="7-2-Chapter-7-amp-LEC-11-note-amp-LEC-13-note"><a href="#7-2-Chapter-7-amp-LEC-11-note-amp-LEC-13-note" class="headerlink" title="| 7.2 | Chapter 7 &amp; LEC 11 note &amp; LEC 13 note"></a>| 7.2 | Chapter 7 &amp; LEC 11 note &amp; LEC 13 note</h3><p>为了允许多于 CPU 数量的进程“同时”运行，操作系统需要提供多路复用(Mutiplexing) 包括 CPU 在内的共享资源。</p>
<p>多路复用面临的挑战：</p>
<blockquote>
<ul>
<li><p>how to switch from one process to another? idea is sample but implementation is opaque.</p>
</li>
<li><p>how to force switches in a way that is transparent to user processes? - <strong>timer interrupts</strong></p>
</li>
<li><p>a locking plan is necessary to avoid races, for <u>CPUs may be switching among processes concurrently</u>.</p>
</li>
<li><p>cannot free a process’s memory and other resources when the process exits because (for example) it <u>can’t free its own kernel stack while still using it</u>.</p>
</li>
<li><p>each core of a multi-core machine must remember which process it is executing so that system calls affect the correct process’s kernel state. - <code>myproc()</code></p>
</li>
<li><p>races(the loss of wakeup) in <code>sleep</code> and <code>wakeup</code>.</p>
</li>
</ul>
</blockquote>
<h4 id="7-2-1-switch-amp-scheduling"><a href="#7-2-1-switch-amp-scheduling" class="headerlink" title="| 7.2.1 | switch &amp; scheduling"></a>| 7.2.1 | switch &amp; scheduling</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">overview of thread switching in xv6</span><br><span class="line">  (the point: switch among threads to interleave many threads on each CPU)</span><br><span class="line">  [diagram: P1, TF1, STACK1, swtch(), CTX1;</span><br><span class="line">            CTXs, swtch(), STACKs, scheduler(), &amp;c]</span><br><span class="line">  TF = trapframe = saved user registers</span><br><span class="line">  CTX = context = saved RISC-V registers</span><br><span class="line">  getting from one process to another involves multiple transitions:</span><br><span class="line">    - user -&gt; kernel; saves user registers in **trapframe**</span><br><span class="line">    - kernel thread -&gt; scheduler thread; saves kernel thread registers in **context**</span><br><span class="line">    - scheduler thread -&gt; kernel thread; restores kernel thread registers from **context**</span><br><span class="line">    - kernel -&gt; user; restores user registers from **trapframe**</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>swtch()</code></p>
<p>只保存被调用者保存(<em>callee saved</em>)寄存器。</p>
<p><code>swtch()</code> 返回到 <code>new-&gt;context-&gt;ra</code> 指向的地址，该地址是这个新线程之前调用 <code>swtch()</code> 的返回地址(<code>sched()/forkret()/scheduler()</code>)。</p>
</li>
<li><p>进程在准备让出 CPU 之前必须满足几个要求：</p>
<ul>
<li><p>获得自己的 <code>p-&gt;lock</code>，以保护 <code>p-&gt;state</code>, <code>cpu-&gt;proc</code>。如果没有 <code>p-&gt;lock</code> 在当前 CPU 执行 <code>yeild()</code> 和 <code>scheduler():swtch()</code> 之间，其他的 CPU 很可能调度到此进程，此时两个 CPU 共用同一个内核栈。</p>
</li>
<li><p>修改进程的状态(<code>p-&gt;state</code>)，修改成 <code>SLEPPING/RUNABLE/ZOMBIE</code>。</p>
</li>
<li><p>这样的函数有：<code>sleep()</code>, <code>yield()</code>, <code>exit()</code> 。</p>
</li>
</ul>
</li>
<li><p><code>scheduler()</code></p>
<ol>
<li>打开中断，遍历 <code>proc[]</code> 找到一个 <code>RUNNALBE</code> 进程(p)(首先会申请当前进程的锁 <code>p-&gt;lock</code>)。</li>
<li>更新 <code>p-&gt;state</code> 为 <code>RUNNING</code>, <code>c-&gt;proc</code> 为当前进程。</li>
<li>调用<code>swtch()</code> 到进程 p。</li>
<li>当被 <code>sleep()/yield()/exit()</code> 调用 <code>sched()</code> 切换回来时，清空 <code>c-&gt;proc</code>, 释放 <code>p-&gt;lock</code>。</li>
<li>如果当前只有 <code>init</code> 和 <code>sh</code> 两个进程，则打开中断并执行指令 <code>wfi</code> 等待中断，否则继续执行。</li>
<li>重复 1. 。</li>
</ol>
</li>
<li><p><code>mycpu()</code></p>
<ul>
<li><code>mycpu()</code> 要求调用者关闭中断，直到使用完 <code>mycpu()</code> 返回的值为止。</li>
<li>因为如果在这期间被中断，<code>hartid</code> 会被修改，导致索引有误。</li>
</ul>
</li>
<li><p><code>myproc()</code></p>
<ul>
<li>关中断。</li>
<li>保存 <code>mycpu()-&gt;proc</code>。</li>
<li>关中断。在这之后被中断是允许的，因为 <code>proc</code> 结构体不依赖 <code>hartid</code>, 我们只需要根据 <code>hartid</code> 找到当前 CPU 正在执行的进程</li>
<li>返回结构体地址。</li>
</ul>
</li>
<li><p><code>sched()</code> 持有 <code>p-&gt;lock</code>，切换到 <code>scheduler()</code> 后，会释放 <code>p-&gt;lock</code>，这两个锁一样吗？– 完全一样</p>
<ul>
<li>因为一个进程 <code>p1</code> 首先是通过 <code>scheduler()</code> 获取了锁，然后再通过 <code>swtch()</code> 返回后释放。</li>
<li>而 <code>p1</code> 调用 <code>sched()</code> 回到的 <code>scheduler()</code> 和当初调度他的 <code>scheduler()</code> 是同一个 CPU, 所以此时 <code>scheduler()</code> 上下文的 <code>p</code> 即 <code>p1</code>。</li>
<li>此外对于 <code>fork()</code> 的子进程，在 <code>scheduler()</code> 开头遍历时获取 <code>p-&gt;lock</code>，在 <code>forkret()</code> 释放。</li>
</ul>
</li>
</ul>
<h4 id="7-2-2-sleep-amp-wakeup"><a href="#7-2-2-sleep-amp-wakeup" class="headerlink" title="| 7.2.2 | sleep &amp; wakeup"></a>| 7.2.2 | sleep &amp; wakeup</h4><blockquote>
<p>one process to <strong>sleep</strong> <u>when waiting for an event</u> and another process to <strong>wake it up</strong> once <u>the event has happened</u>.</p>
</blockquote>
<p>比如以下事件(event)</p>
<ul>
<li>waiting pipes</li>
<li>disk r&#x2F;w</li>
<li><code>sys_wait()</code></li>
</ul>
<p>loss wakeups (broken sleep: wakeup before sleep).</p>
<p><em>loss wakeups</em> 的解决方法:</p>
<ul>
<li>调用 <code>sleep()</code> 之前必须保证持有调用 <code>wakeup()</code> 也需要的  <em>conditional lock</em></li>
<li>xv6 通过修改 <code>sleep()</code> 接口，<code>sleep()</code> 接收除了 <em>channel</em> 以外的另一个参数，<em>conditional lock</em></li>
</ul>
<p><code>sleep()</code></p>
<ul>
<li>申请 <code>p-&gt;lock</code>, 释放 <em>conditional lock</em>。</li>
<li>更新 <code>p-&gt;chan = chan</code>, <code>p-&gt;state = SLEEPING</code>。</li>
<li>调用 <code>sched()</code> 让出 CPU。</li>
<li>当 <code>p-&gt;state</code> 被 <code>wakeup()/kill()/exit()</code> 修改后，会被 <code>sheduler()</code> 调度，从 <code>sched()</code> 返回。</li>
<li>清空 <code>p-&gt;chan</code>。</li>
<li>重新申请 <em>conditional lock</em> 后返回。</li>
</ul>
<p><code>wakeup()</code></p>
<ul>
<li>遍历 <code>procp[]</code> 匹配 <code>p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan</code>, 在这之前会获取 <code>p-&gt;lock</code>。</li>
<li>更新 <code>p-&gt;state = RUNNABLE</code>。</li>
<li>释放 <code>p-&gt;lock</code> 返回。</li>
</ul>
<p>注意：</p>
<ul>
<li><u>通常在调用 <code>wakeup()</code> 之前应该申请相应的 <em>conditional lock</em>， <code>wakeup()</code> 返回后释放</u>。</li>
<li>多个进程使用同一个 <em>sleeping channel</em> 是允许的，因为在 <code>sleep()</code> 返回前会重新申请 <em>conditional lock</em>, 尽管这些进程都会被 <code>wakeup()</code> 但是只有一个能成功申请到锁。</li>
</ul>
<h4 id="7-2-3-wait-exit-amp-kill"><a href="#7-2-3-wait-exit-amp-kill" class="headerlink" title="| 7.2.3 | wait, exit &amp; kill"></a>| 7.2.3 | wait, exit &amp; kill</h4><p><code>wait()</code></p>
<ul>
<li>找到一个 <code>ZOMBIE</code> 子进程。</li>
<li>释放该进程 (<code>freeproc()</code>)。</li>
<li>返回子进程 <code>pid</code>。</li>
<li>如果没有没有子进程，或被 kill,则直接返回。</li>
<li>调用 <code>sleep()</code> 等待子进程 <code>exit()</code> 时 调用 <code>wakeup1()</code>。</li>
</ul>
<p>注意：</p>
<blockquote>
<ul>
<li><p><code>wait</code> often holds two locks, xv6 must obey the same locking <strong>order</strong> (<u>parent, then child</u>) in order to avoid deadlock.</p>
</li>
<li><p><code>wait</code> uses <code>np-&gt;parent</code> without holding <code>np-&gt;lock</code>.  It is possible that <code>np</code> is an ancestor of the current process, in which case acquiring <code>np-&gt;lock</code> could cause a <strong>deadlock</strong>. A process’s <code>parent</code> field is only changed by its parent, so if <code>np-&gt;parent==p</code> is true, <u>the value can’t change unless the current process changes it</u>.</p>
</li>
</ul>
</blockquote>
<ul>
<li>在判断 <code>np-&gt;parent==p</code> 后才会申请 <code>np-&gt;lock</code></li>
</ul>
<p><code>exit()</code></p>
<blockquote>
<p><code>exit</code> allows a process to <strong>terminate</strong> itself</p>
</blockquote>
<ul>
<li>关闭了所有已打开的文件</li>
<li>调用 <code>wakeup()</code> 唤醒 <code>initproc</code>，之后 <code>initproc</code> 继续执行 <code>wait()</code>。</li>
<li>申请 <code>p-&gt;parent-&gt;lock</code> 因为要唤醒父进程。</li>
<li>再申请 <code>p-&gt;lock</code> 因为要更新 <code>p-&gt;state</code> 且重新设置父进程为(reparent to) <code>initproc</code>。注意由于上面的顺序(<em>memory ordering</em>)先父进程再子进程。</li>
<li><em>reparent</em> 。</li>
<li>唤醒父进程。</li>
<li>修改 <code>p-&gt;state=ZOMBIE</code>。</li>
<li>调用 <code>sched()</code> 让出 CPU。</li>
</ul>
<p>注意：</p>
<ul>
<li>在修改 <code>p-&gt;state=ZOMBIE</code> 之前唤醒父进程是可以的，因为当父进程从 <code>wait()</code> 的 <code>sleep()</code> 返回时，最终会申请 <code>np-&gt;lock</code>。直到 <code>exit()</code> 调用 <code>sched()</code> 之后，<code>scheduler()</code> 才会释放该子进程的锁。</li>
</ul>
<p><code>kill()</code></p>
<blockquote>
<p><code>kill</code> lets one process request that <strong>another</strong> terminate.</p>
<p>It would be too complex for <code>kill</code> to <strong>directly destroy</strong> the victim process, since <u>the victim might be executing on another CPU</u>, perhaps in the middle of a sensitive sequence of updates to kernel data structures.<br><u>Thus kill does very little</u>:</p>
<ul>
<li>sets the victim’s <code>p-&gt;killed</code></li>
<li>if it is sleeping, wakes it up.(<code>p-&gt;state = RUNNABLE</code>)</li>
</ul>
</blockquote>
<p>注意：</p>
<ul>
<li><code>kill</code> 直接唤醒当前进程很可能造成目标进程从 <code>sleep()</code> 中返回。此时很可能当前程序希望 <code>sleep()</code> 等待的条件还<strong>没有达成</strong>，因而造成程序错误。</li>
<li>所以一些封装 <code>sleep()</code> 的循环，当 <code>sleep()</code> 返回时，需要检查 <code>p-&gt;kill</code></li>
<li>对于一些要求原子操作的循环，比如读写磁盘，则相反必须等原子操作完成后再检查 <code>p-&gt;kill</code></li>
</ul>
<h3 id="7-3-Lab-Multithreading"><a href="#7-3-Lab-Multithreading" class="headerlink" title="| 7.3 | Lab: Multithreading"></a>| 7.3 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/thread.html">Lab: Multithreading</a></u></h3><img alt="图 8" src="/images/image-20240327062655.png" />  

<h4 id="7-3-1-Uthread-switching-between-threads-moderate"><a href="#7-3-1-Uthread-switching-between-threads-moderate" class="headerlink" title="| 7.3.1 | Uthread: switching between threads (moderate)"></a>| 7.3.1 | Uthread: switching between threads (moderate)</h4><p>需要注意的是：</p>
<ul>
<li>初始化 <code>sp=t-&gt;stack + STACK_SIZE</code> 即 <code>sp</code> 是递减的。</li>
<li><code>thread_switch()</code> 之后不用更新 <code>current_thread = t;</code> 因为每次都会从头调用调度器，已经设置了 <code>current_thread</code>。</li>
</ul>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/3752d8e7ae9c90e6d079f9ade6531e3b78b19dba">这部分代码在这里</a></u></p>
<h4 id="7-3-2-Using-threads-moderate"><a href="#7-3-2-Using-threads-moderate" class="headerlink" title="| 7.3.2 | Using threads (moderate)"></a>| 7.3.2 | Using threads (moderate)</h4><p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/b01053525a0498534510db5e6ba212e7540ff84c">这部分代码在这里</a></u></p>
<h4 id="7-3-3-Barrier-moderate"><a href="#7-3-3-Barrier-moderate" class="headerlink" title="| 7.3.3 | Barrier(moderate)"></a>| 7.3.3 | Barrier(moderate)</h4><p>只需要遵守调用 <code>wakeup()</code> 的通用方法<a href="#7-2-2-sleep-amp-wakeup">| 7.2.2 | sleep &amp; wakeup</a></p>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/d964e36860a2ea66b85836d6523cd07cd846ef9c">这部分代码在这里</a></u></p>
<h2 id="8-Lab-lock-相关"><a href="#8-Lab-lock-相关" class="headerlink" title="| 8 | Lab lock 相关"></a>| 8 | Lab lock 相关</h2><h3 id="8-1-Lab-locks"><a href="#8-1-Lab-locks" class="headerlink" title="| 8.1 | Lab: locks"></a>| 8.1 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/lock.html">Lab: locks</a></u></h3><h4 id="8-1-1-Memory-allocator-moderate"><a href="#8-1-1-Memory-allocator-moderate" class="headerlink" title="| 8.1.1 | Memory allocator (moderate)"></a>| 8.1.1 | Memory allocator (moderate)</h4><ul>
<li>不用对所有 CPU 等分 <code>freelist</code>，因为不确定 CPU 数量不确定，只需要给 CPU0 分配所有内存，其他的 CPU 调用 <code>steal()</code> 即可</li>
<li><code>steal()</code> 不能传入调用他时的 <code>cpuid</code> 并且不遍历这个 CPU。因为很可能 <code>steal()</code> 执行过程中被调度，更新了 <code>freelist()</code>，不遍历会导致丢失部分内存。</li>
</ul>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/1a92ee4843238810d398e472e233bae95b219625">这部分代码在这里</a></u></p>
<h4 id="8-1-2-Buffer-cache-hard"><a href="#8-1-2-Buffer-cache-hard" class="headerlink" title="| 8.1.2 | Buffer cache (hard)"></a>| 8.1.2 | Buffer cache (hard)</h4><p>用哈希表代替原来 <em>buffer cache</em> 的一个双链表，来避免 <em>lock contention</em></p>
<p>后补</p>
<p>自我感觉这部分(并发，死锁，条件竞争)很难调试，内核出错的位置和代码错误的位置有一定距离，很难通过 gdb 找到。</p>
<p>LEC 15，Frans 教授提到可以通过 “write down assertion for invariants.”</p>
<p>后面再做吧，先把时间留给文件系统和 mmap。</p>
<h2 id="9-Lab-fs-相关"><a href="#9-Lab-fs-相关" class="headerlink" title="| 9 | Lab fs 相关"></a>| 9 | Lab fs 相关</h2><h3 id="9-1-LEC-14-note"><a href="#9-1-LEC-14-note" class="headerlink" title="| 9.1 | LEC 14 note"></a>| 9.1 | LEC 14 note</h3><h4 id="9-1-1-Buffer-cache-layer"><a href="#9-1-1-Buffer-cache-layer" class="headerlink" title="|9.1.1| Buffer cache layer"></a>|9.1.1| Buffer cache layer</h4><p><code>bread()</code></p>
<p><code>bwrite()</code></p>
<p><code>brelse()</code></p>
<p><code>balloc()</code></p>
<p><code>bfree()</code></p>
<h4 id="9-1-2-inode-layer-icache"><a href="#9-1-2-inode-layer-icache" class="headerlink" title="|9.1.2| inode layer(icache)"></a>|9.1.2| inode layer(icache)</h4><p><code>ialloc()</code></p>
<p><code>iget()</code></p>
<p><code>ilock()</code></p>
<p><code>iput()</code></p>
<p><code>iupdate()</code></p>
<p><code>bmap()</code>: 返回 <code>inode.data.logic_block_number</code> 对应的实际块号(block number)。</p>
<p><code>itrunc()</code>: 释放 <code>inode</code> 的数据占用的所有块。</p>
<p><code>readi()</code></p>
<p><code>writei()</code></p>
<h3 id="9-2-LEC-15-note-amp-Chapter-8"><a href="#9-2-LEC-15-note-amp-Chapter-8" class="headerlink" title="| 9.2 | LEC 15 note &amp; Chapter 8"></a>| 9.2 | LEC 15 note &amp; Chapter 8</h3><h4 id="9-2-1-logging-layer"><a href="#9-2-1-logging-layer" class="headerlink" title="|9.2.1| logging layer"></a>|9.2.1| logging layer</h4><p>日志(<em>log</em>) 机制原理：</p>
<blockquote>
<p>write-ahead log rule:</p>
<ul>
<li>install <em>none</em> of a transaction’s writes to disk</li>
<li>until <em>all</em> writes are in the log on disk,</li>
<li>and the logged writes are marked committed.</li>
</ul>
</blockquote>
<p>组提交(<em>group commit</em>)：</p>
<blockquote>
<ul>
<li><p>the logging system only commits when no file-system system calls are underway.</p>
</li>
<li><p>commit order can’t be changed</p>
</li>
</ul>
</blockquote>
<p>固定日志大小的问题：</p>
<blockquote>
<ul>
<li><p>一次 <code>write()</code> 的大小不能超过日志定义的块的数量。</p>
</li>
<li><p>unlinking a large file might write many bitmap blocks and an inode.</p>
</li>
</ul>
</blockquote>
<p><code>begin_op()</code></p>
<p><code>log_write()</code></p>
<p><code>end_op()</code></p>
<p><code>commit()</code></p>
<p><code>write_log()</code>: 把事务(<em>transaction</em>)涉及的块(保存在内存 <code>log</code> 结构体的 <code>log.lh.block[]</code>) 写到磁盘的存放日志块的区域(block 2-31)。</p>
<p><code>write_head()</code>: 提交点(<em>commit point</em>), 把内存中的日志头写到磁盘的日志头。</p>
<p><code>install_trans()</code>: 根据日志头把磁盘中的日志写到对应的位置(<em>home location</em>)。</p>
<p><code>recover_from_log()</code></p>
<h4 id="9-2-2-Directory-pathname-file-descriptor-layer"><a href="#9-2-2-Directory-pathname-file-descriptor-layer" class="headerlink" title="|9.2.2| Directory, pathname, file descriptor layer"></a>|9.2.2| Directory, pathname, file descriptor layer</h4><p><code>dirlookup()</code></p>
<p><code>dirlink()</code></p>
<p><code>namex()</code>: 根据 <code>path</code> 返回对应 <em>icache</em> 地址。</p>
<p><code>skipelem()</code>: 返回子路径，设置 <em>name</em>。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span></span><br></pre></td></tr></table></figure>

<p><code>filealloc()</code></p>
<p><code>filedup()</code></p>
<p><code>fileclose()</code></p>
<p><code>fileread()</code></p>
<p><code>filewrite()</code></p>
<h3 id="9-3-LEC-16-note"><a href="#9-3-LEC-16-note" class="headerlink" title="| 9.3 | LEC 16 note"></a>| 9.3 | LEC 16 note</h3><p>xv6 日志系统的问题：</p>
<ul>
<li>synchronize: 必须等当前事务完全结束，才能继续。</li>
<li>write twice</li>
</ul>
<p>ext3:</p>
<ul>
<li>异步(async): 系统调用(syscall)返回并不代表需要的事务成功完成，所以用户进程必须考虑到这种情况(<code>fsync(fd)</code>)</li>
<li>批处理(batching)<ul>
<li>一次只有一个 “open transaction”，可以包含多个 <code>syscall</code></li>
</ul>
</li>
<li>并发(concurrency)<ul>
<li>当前 “open transaction” 的所有系统调用结束后才能结束(close)该事务。</li>
<li>结束事务后会缓存到内存中，按顺序依次提交(commit)到磁盘的 log 区域。</li>
<li>因此 ext3 不像 xv6，必须等当前事务写入磁盘日志区，提交，<em>install</em>，清空日志区完成后再开始。</li>
</ul>
</li>
</ul>
<p>ext3 的三种模式：</p>
<ul>
<li>journaled data: 和 xv6 一样，先写入磁盘日志区，然后再写原本的位置(<em>home location</em>)</li>
<li>ordered data: 只把元数据(<em>metadata</em>)写入磁盘日志区，而文件数据直接写入原本的位置，但是必须注意要先写数据，再写元数据。</li>
<li>writeback</li>
</ul>
<h3 id="9-4-Lab-file-system"><a href="#9-4-Lab-file-system" class="headerlink" title="| 9.4 | Lab: file system"></a>| 9.4 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/fs.html">Lab: file system</a></u></h3><img alt="图 10" src="/images/image-20240331110325.png" />  

<h4 id="9-4-1-Large-files-moderate"><a href="#9-4-1-Large-files-moderate" class="headerlink" title="| 9.4.1 | Large files (moderate)"></a>| 9.4.1 | Large files (moderate)</h4><p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/ec3a188925a48e2465c1741099bc4ab1119a53b0">这部分代码在这里</a></u></p>
<h4 id="9-4-2-Symbolic-links-moderate"><a href="#9-4-2-Symbolic-links-moderate" class="headerlink" title="| 9.4.2 | Symbolic links (moderate)"></a>| 9.4.2 | Symbolic links (moderate)</h4><p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/3ec2e78986e6438f496266c371d31323b1403272">这部分代码在这里</a></u></p>
<h2 id="10-Lab-mmap-相关"><a href="#10-Lab-mmap-相关" class="headerlink" title="| 10 | Lab mmap 相关"></a>| 10 | Lab mmap 相关</h2><h3 id="10-1-LEC-17-note"><a href="#10-1-LEC-17-note" class="headerlink" title="| 10.1 | LEC 17 note"></a>| 10.1 | LEC 17 note</h3><p>一些通过使用内核提供的虚拟内存原语&#x2F;特性(primitives) 如: <code>trap</code>, <code>prot1,protn</code>, <code>dirty</code>, <code>map2</code> (<code>sigaction()</code>, <code>mprotect()</code>, <code>mmap()</code>)的算法。</p>
<ul>
<li><p><em>VMA</em>(Virtual Memory Area)</p>
<p>记录并描述一段连续的内存区域，包括起始终止地址，权限，相关文件指针等</p>
</li>
</ul>
<h3 id="10-2-LEC-18-note"><a href="#10-2-LEC-18-note" class="headerlink" title="| 10.2 | LEC 18 note"></a>| 10.2 | LEC 18 note</h3><p>micro kernel 暂时忽略。</p>
<h3 id="10-3-LEC-19-note"><a href="#10-3-LEC-19-note" class="headerlink" title="| 10.3 | LEC 19 note"></a>| 10.3 | LEC 19 note</h3><p><strong>Virtual Machine!!!!</strong></p>
<p>虚拟化需要解决的三个问题：怎样安全的有效的使得虚拟机(guest VM), 执行指令，访问内存，读写设备。</p>
<p>虚拟机不能运行在宿主(host)内核中。</p>
<p>对应三种虚拟化 <strong>CPU 虚拟化</strong>，<strong>内存虚拟化</strong>，<strong>I&#x2F;O 虚拟化</strong></p>
<p>辅助参考:🔗 <a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/virtualization/basic-knowledge/basic-knowledge/">CTF Wiki-Pwn-Virtualization-基础知识</a></p>
<h4 id="10-3-1-trap-and-emulate"><a href="#10-3-1-trap-and-emulate" class="headerlink" title="| 10.3.1 | trap-and-emulate"></a>| 10.3.1 | trap-and-emulate</h4><p>VMM 完全由软件模拟虚拟机(VM)的指令，也就是<u>完全软件虚拟化 CPU</u>是可行的，并且移植性很好，但是最大的问题是完全由软件模拟会很慢。</p>
<p>当 VM 执行特权指令()时，VMM 从 <em>trap</em> 中接手，模拟执行相应特权指令。</p>
<p>比如虚拟机 <code>ecall</code>，但是会陷入(trap)到宿主机内核(host kernel)，然后，VMM 接手，把相关的特权寄存器(<code>scause</code>, <code>sepc</code>, <code>stvac</code>…)复制到 VMM 针对虚拟机模拟的相应特权寄存器中</p>
<p>然后 <u>设置宿主 <code>sepc</code> 为 模拟的 <code>stvac</code> , 设置虚拟机模式(mode bit)为 <em>supervis mode</em> , 然后宿主机执行 <code>sret</code> 返回到虚拟机内核(guest kernel)。</u></p>
<p>这样虚拟机的内核才能处理来自虚拟机用户态(guest userspace)的 <em>trap</em>。</p>
<p>当虚拟机内核处理结束执行 <code>sret</code> 的时候，同样会陷入宿主机的内核(trap into host kernel), (因为虚拟机内核实际上是运行在宿主机的用户态)然后宿主机内核交给 VMM 处理。</p>
<p>VMM 模拟相应指令(把模拟 <code>sepc</code> 拷贝到 <code>pc</code>，修改虚拟机为用户模式)回到虚拟机用户态。整个过程就像 guest userspace-&gt; guest kernel space -&gt; guest userspace 一样。</p>
<p>另一个问题页表(pagetable)，VMM 不能让虚拟机设置真正的 <code>satp</code>，这样会使得虚拟机可以访问任意物理内存。同时 VMM 需要把真实的物理地址(Host Physical Address)针对每一个虚拟机，抽象成虚拟机的物理地址(Guest Physical Address)。</p>
<p>VMM 因此维护一个对应映射表(shallow pagetable)用于设置真正的 <code>satp</code> 使用 MMU 翻译地址, <em>shallow pagetable</em>的内容是 gva:hpa。</p>
<p>最后是设备问题。</p>
<ul>
<li>VMM 模拟设备。</li>
<li>VMM 虚拟设备，并提供接口给虚拟机。因而虚拟机的设备驱动可以与 VMM 内支持的设备进行高效交互，而不是需要陷入 VMM。</li>
<li><em>pass-through</em> 例如网卡。</li>
</ul>
<h4 id="10-3-2-hardware-support"><a href="#10-3-2-hardware-support" class="headerlink" title="| 10.3.2 | hardware support"></a>| 10.3.2 | hardware support</h4><p>intel VT-x</p>
<ul>
<li>VMCS</li>
<li>EPT</li>
</ul>
<h4 id="10-3-3-Dune-Safe-User-level-Access-to-Privileged-CPU-Features"><a href="#10-3-3-Dune-Safe-User-level-Access-to-Privileged-CPU-Features" class="headerlink" title="| 10.3.3 | Dune: Safe User-level Access to Privileged CPU Features"></a>| 10.3.3 | Dune: Safe User-level Access to Privileged CPU Features</h4><p>一个 Linux 模块(LKM)，给普通程序提供使用 intel VT-x 的接口，实现或者优化沙盒(sandbox)，用户内存管理(memory management)，<em>garbage collector</em> 等。</p>
<h3 id="10-4-LEC-20-note"><a href="#10-4-LEC-20-note" class="headerlink" title="| 10.4 | LEC 20 note"></a>| 10.4 | LEC 20 note</h3><h3 id="10-5-Lab-mmap"><a href="#10-5-Lab-mmap" class="headerlink" title="| 10.5 | Lab: mmap"></a>| 10.5 | <u><a target="_blank" rel="noopener" href="https://pdos.lcs.mit.edu/6.828/2020/labs/mmap.html">Lab: mmap</a></u></h3><img alt="图 11" src="/images/image-20240403100745.png" />  

<p><code>MAP_SHARED</code> 的问题:</p>
<ul>
<li>对于两个进程同时 <code>MAP_SHARED</code> 相同文件，之后进程 1 修改文件，该文件在 <code>munmap()</code> 时写进文件系统，并且进程 2 由于在更新前调用的 <code>mmap()</code>，所以不能看见更新，除非进程 1 调用 <code>msync()</code> 并且指定 <code>MS_INVALIDATE</code> 标记进程 2 相应地址无效，使得进程 2 重新读文件。</li>
<li>所以对于 <code>MAP_SHARED</code> 的修改，这里直接写回原来的位置即可，不用管是否其他进程已经 <code>mmap()</code> 相同文件。</li>
<li>不过在 Linux 上测试时发现，进程 2 能够及时发现改变，应该是 Linux 在实现上两个进程用的同一个缓冲区的缘故。</li>
</ul>
<p><code>MAP_PRIVATE</code> 的问题：</p>
<ul>
<li>即使 <em>fd</em> 对应的文件不可写，但是如果设置了 <code>MAP_PRIVATE</code> 仍然可以。</li>
</ul>
<p><em>addr</em> 为 0 的问题:</p>
<ul>
<li>此时意味着 内核必须选择一个”合适”的地址。</li>
<li>xv6 的 <code>sbrk()</code> 会一直增加虚拟地址空间，直到没有内存可以分配。</li>
<li>并且 <code>mmap()</code> 只是把文件映射到进程的虚拟地址空间，不应该增加 <code>proc-&gt;sz</code></li>
<li>因而 <code>mmap()</code> 选择的地址应该和 <code>sbrk()</code> 分开。</li>
</ul>
<p><em>length</em> 和 <em>off</em> 的问题：</p>
<ul>
<li><em>length</em> 不用限制，如果超出文件的大小，也没事，因为会根据 <em>length</em> 分配物理内存。</li>
<li><em>off</em> 大于文件的大小则应该返回错误。</li>
<li><code>readi()</code>, 和 <code>writei()</code> 都应该基于 <em>off</em>。</li>
</ul>
<p><code>munmp()</code>问题：</p>
<ul>
<li><code>munmap()</code> 之后，访问 [addr, addr+length) 是非法的。</li>
<li>如果 <em>length</em> 不是页对其的，应该向上取整，因为之前 <code>mmap()</code> 的时候不足一页的会补齐。</li>
<li>如果 <code>mmap()</code> 了连续的 3 页，但是只 <code>munmap()</code> 第二页，其他两页应该继续有效，这是需要再找一个 VMA，但是 <code>mmaptest</code> 没有这种情况，所以暂时不考虑。</li>
<li><u><strong>由于我们是延迟映射(<em>lazy mmap</em>) 所以在 <code>munmap()</code> 的时候，<code>walk()</code> 返回 0 或者 <code>PTE_V</code> 是 0 是很正常的。</strong></u>。</li>
</ul>
<p><code>fork()</code> 问题：</p>
<ul>
<li>子进程可以看见父进程 <code>MAP_PRIVATE</code> 的改变。</li>
<li>所以子进程应该完全复制一份父进程的 VMA 空间(这里就不实现 COW 了)。</li>
<li>如果子进程在 <code>uvmcopy()</code> 第一个以后的 VMA 失败了(比如当父进程 mmap 了很大的文件，并且都分配了内存)，应该释放在前面分配的 VMA，否则就会损失这些 VMA，这个还没实现。</li>
</ul>
<p>📌 <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/xv6-riscv/commit/447462ee25dccd2739b8c1c5a7c419938aff2603">这部分代码在这里</a></u></p>
<h2 id="11-Lab-net-相关"><a href="#11-Lab-net-相关" class="headerlink" title="| 11 | Lab net 相关"></a>| 11 | Lab net 相关</h2><p>后半学期有一门 《网络协议栈分析》的课，留在后面吧。</p>
<!-- ### | 11.1 | LEC 21 note

### | 11.2 | <u>[Lab: networking](https://pdos.lcs.mit.edu/6.828/2020/labs/net.html)</u>

## | 12 | Meltdown & RCU

### | 12.1 | LEC 22 note

### | 12.2 | LEC 23 note

## | 13 | 总结

### | 13.1 | 什么是内核，为什么需要内核

#### | 13.1.1 | 什么是内核

本质上，内核只是一段程序而已，或者说一个软件。CPU 同样也是取指，兼指，执行，往复循环。

和普通程序(用户态程序)相比，内核拥有更高的权限，有进一步访问物理硬件能力。比如 RISCV，内核通常运行在 *superviser mode*，可以读写部分特权寄存器。

#### | 13.1.2 | 为什么需要内核

### | 13.2 | 内核要满足哪些需求，如何实现 -->

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a><a href="/tags/MIT/">MIT</a><a href="/tags/Experiment/">Experiment</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">notion-down</a> and
    Theme by <a href="https://github.com/kaedea/hexo-theme-hacker" target="_blank">hexo-theme-hacker</a>
    </br>
    
      &copy; 2024
        sev1n75 &lt;sev1n75@qq.com&gt;
          
  </p>
</footer>
    
  </div>
</div>
</body>
</html>