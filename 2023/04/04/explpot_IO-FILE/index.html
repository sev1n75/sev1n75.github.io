<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
    <title>
      _IO_FILE利用 | sev1n75 | Binary Exploit</title>

  
  <meta name="author" content="sev1n75">
  

  
  <meta name="description" content="CTF Pwn 选手，以此博客分享技术和学习过程">
  

  
  
  <meta name="keywords" content="_IO_FILE">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="_IO_FILE利用"/>

  <meta property="og:site_name" content="sev1n75"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/images/favicon.png" type="image/png" rel="icon">
  <link href="/images/favicon.png" rel="apple-touch-icon" sizes="76x76">
  <link rel="alternate" href="/atom.xml" title="sev1n75" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <link href="https://fonts.lug.ustc.edu.cn/css?family=Lato|Rubik" rel="stylesheet">
  <script src="/js/pangu-407.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>
<script>
  document.addEventListener(' DOMContentLoaded', () => {
    pangu.autoSpacingPage();
  });
</script>

<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">
        sev1n75's Tech Blog
      </a>
    </h1>
    <p class="site-description">
      
        路漫漫其修远兮，吾将上下而求索
          
    </p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">
            主页
          </a></li>
        
        <li><a href="/archives">
            归档
          </a></li>
        
        <li><a href="/tags">
            标签
          </a></li>
        
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>_IO_FILE利用</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/04/04/explpot_IO-FILE/" rel="bookmark">
        <time class="entry-date published" datetime="2023-04-04T04:17:32.000Z">
          2023-04-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        

<script type="text/javascript">
    function convertRemToPixels(rem) {    
        return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
    window.onscroll = function() {
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop > convertRemToPixels(40)) {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'visible';
        } else {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'hidden';
        }
    }
</script>


<div id="toc" class="toc-article">
      <div class="toc-content">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-text">| 0 | 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">| 1 | 相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-fopen-fread-fwrite"><span class="toc-text">| 1.1 | fopen,fread,fwrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-FILE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">| 1.2 | FILE结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-FILE-Struct-Buffer-Pointers"><span class="toc-text">| 1.2.1 | FILE Struct Buffer Pointers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-vtable-%E5%92%8C-IO-FILE-plus"><span class="toc-text">| 1.3 | vtable 和 _IO_FILE_plus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-fread-fwrite-%E5%8E%9F%E7%90%86"><span class="toc-text">| 1.4 | fread, fwrite 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-fread"><span class="toc-text">| 1.4.1 | fread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-fwrite"><span class="toc-text">| 1.4.2 | fwrite</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">| 2 | 利用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E4%BA%8Evtable%E7%9A%84%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-text">| 2.1 | 基于vtable的利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E4%B8%80%E8%88%AC%E4%BC%AA%E9%80%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="toc-text">| 2.1.1 | 一般伪造结构体有两个主要思路:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E8%A7%A6%E5%8F%91-IO-%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%80%E8%88%AC%E6%9C%89%E4%B8%89%E7%A7%8D"><span class="toc-text">| 2.1.2 | 触发 IO 流的操作一般有三种</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-house-of-apple2"><span class="toc-text">| 2.2 | house of apple2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">| 2.2.1 | 原理分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E8%B0%83%E7%94%A8%E9%93%BE%E6%A3%80%E6%9F%A5%E7%BB%95%E8%BF%87"><span class="toc-text">| 2.2.2 | 调用链检查绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE-fake-FILE-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">| 2.2.3 | 如何设置 fake FILE 结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9F%BA%E4%BA%8E-fread-%E5%92%8C-fwrite-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99"><span class="toc-text">| 2.3 | 基于 fread 和 fwrite 任意地址读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-text">| 2.3.1 | 任意地址写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="toc-text">| 2.3.2 | 任意地址读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E4%BF%AE%E6%94%B9-stdout-%E6%B3%84%E6%BC%8F-libc"><span class="toc-text">| 2.3.3 | 修改 stdout 泄漏 libc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E4%BF%AE%E6%94%B9-stdin-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-text">| 2.3.4 | 修改 stdin 任意地址写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%80%E4%BA%9B%E5%BA%9F%E8%AF%9D"><span class="toc-text">| 3 | 一些废话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-3-28"><span class="toc-text">2023.3.28</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-4-3"><span class="toc-text">2023.4.3</span></a></li></ol></li></ol>
      </div>
</div>
<style>
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>



        <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="| 0 | 前言"></a>| 0 | 前言</h2><p>关于 FILE(_IO_FILE) 结构体的利用，网络上博客比较多，但是很杂很乱，我学习的时候比较迷茫。这篇博客中，我总结了我学习 FILE 结构体的一些经验和一些资料。</p>
<blockquote>
<p>✅最近一次更新：2023-11-27</p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="1-相关知识"><a href="#1-相关知识" class="headerlink" title="| 1 | 相关知识"></a>| 1 | 相关知识</h2><blockquote>
<p>参考资料：</p>
<p><u><a target="_blank" rel="noopener" href="https://dojo.pwn.college/software-exploitation/file-struct-exploits">pwn.college-File Struct Exploits</a></u></p>
<p><u><a target="_blank" rel="noopener" href="https://loora1n.github.io/2022/12/07/【IO_FILE】源码详解-part2/">Pwn✌️ 鹭雨师傅的博客</a></u></p>
</blockquote>
<h3 id="1-1-fopen-fread-fwrite"><a href="#1-1-fopen-fread-fwrite" class="headerlink" title="| 1.1 | fopen,fread,fwrite"></a>| 1.1 | fopen,fread,fwrite</h3><p>由于 <code>open()</code>, <code>read()</code>, <code>write()</code> 是基于文件描述符(File Descriptor)也就是<code>fd</code>操作的函数，<strong>每次调用</strong>时都需要切换成内核态进行复杂的<code>File Descriptor Translation</code>，所以开销较大。</p>
<p>因此 glibc 提供了更为高效的 <code>fopen()</code>, <code>fread()</code> 和 <code>fwrite()</code>，以及系列辅助的IO函数。他们都是基于文件指针(File Pointer)即<code>fp</code>操作的函数。</p>
<p>File Pointer 是指向 FILE 结构体的指针(<code>FILE* fp</code>)。</p>
<p><code>fread</code> 的简单算法是: 当我们需要从文件读数据时，先读到缓冲区并且尽可能填满缓冲区，程序需要的时候从缓冲区读数据。等缓冲区所有数据都被读入或者调用了 <code>fflush</code> 时，再调用 <code>SYS_read</code> 从文件中读入后续的数据填入缓冲区。</p>
<p><code>fwrite</code> 的简单算法是: 当我们需要写数据到目标文件时，先写到缓冲区等缓冲区满或者调用<code>fflush()</code>时再调用<code>SYS_write</code>写到文件里。</p>
<blockquote>
<p>注：上面讲的文件当然也包括了 stdin, stdout, stderr</p>
</blockquote>
<h3 id="1-2-FILE结构体"><a href="#1-2-FILE结构体" class="headerlink" title="| 1.2 | FILE结构体"></a>| 1.2 | FILE结构体</h3><p>FILE 结构体源码可以<a href = "https://elixir.bootlin.com/glibc/latest/source/libio/bits/types/struct_FILE.h#L49">点这里</a>查看。</p>
<h4 id="1-2-1-FILE-Struct-Buffer-Pointers"><a href="#1-2-1-FILE-Struct-Buffer-Pointers" class="headerlink" title="| 1.2.1 | FILE Struct Buffer Pointers"></a>| 1.2.1 | FILE Struct Buffer Pointers</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _flags;  <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="comment">// flags 用来指明如何设置buffer以及如何与当前文件交互，比如标识 比如当前文件是否可读或可写等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line"><span class="type">char</span> *_IO_read_ptr; <span class="comment">/* Current read pointer */</span> <span class="comment">// 指向当前缓冲区 read from file but unread by user 数据的开始</span></span><br><span class="line"><span class="type">char</span> *_IO_read_end; <span class="comment">/* End of get area. */</span>     <span class="comment">// 指向当前缓冲区 read from file 数据的结尾同时也是 unread by user 数据的结尾</span></span><br><span class="line"><span class="type">char</span> *_IO_read_base; <span class="comment">/* Start of putback+get area. */</span> <span class="comment">// 指向当前缓冲区 read from file 的开头</span></span><br><span class="line"><span class="type">char</span> *_IO_write_base; <span class="comment">/* Start of put area. */</span>  <span class="comment">// 指向当前缓冲区 written from user 数据的开头</span></span><br><span class="line"><span class="type">char</span> *_IO_write_ptr; <span class="comment">/* Current put pointer. */</span> <span class="comment">// 指向当前缓冲区 written from user but unwritten to file 数据的开头 </span></span><br><span class="line"><span class="type">char</span> *_IO_write_end; <span class="comment">/* End of put area. */</span>     <span class="comment">// 指向当前缓冲区 written from user 数据的结尾同时也是 unwritten to file 数据的结尾</span></span><br><span class="line"><span class="type">char</span> *_IO_buf_base; <span class="comment">/* Start of reserve area. */</span>  <span class="comment">// 指向缓冲区的开头</span></span><br><span class="line"><span class="type">char</span> *_IO_buf_end; <span class="comment">/* End of reserve area. */</span>   <span class="comment">// 指向缓冲区的结尾</span></span><br><span class="line"><span class="comment">// ···</span></span><br><span class="line"><span class="type">int</span> _fileno;  <span class="comment">// 对应文件的 fd</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-vtable-和-IO-FILE-plus"><a href="#1-3-vtable-和-IO-FILE-plus" class="headerlink" title="| 1.3 | vtable 和 _IO_FILE_plus"></a>| 1.3 | vtable 和 _IO_FILE_plus</h3><p><code>_IO_FILE_plus</code> 在 <code>FILE</code>结构体的基础上封装了一个指向<code>_IO_jump_t</code>的指针<code>vtable</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>vtable(virtual table) 是<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/latest/source/libio/libioP.h#L293">_IO_jump_t</a>的指针其中存放了某些函数的指针</p>
<p>举个例子：如果 vtable 的值存在寄存器 rax 中那么调用 vtable 中的某个偏移为0x68的函数时会执行<code>call *0x68(%rax)</code>即 vtable 里面存的不是函数的入口地址，而是保存函数入口地址的一个地址</p>
<h3 id="1-4-fread-fwrite-原理"><a href="#1-4-fread-fwrite-原理" class="headerlink" title="| 1.4 | fread, fwrite 原理"></a>| 1.4 | fread, fwrite 原理</h3><blockquote>
<p>IO_FILE 调用的本家函数都是用的虚表，而且全是宏定义，在源码里真的难找</p>
<p>源码分析可以看 <u><a target="_blank" rel="noopener" href="https://loora1n.github.io/2022/12/07/【IO_FILE】源码详解-part2/">Pwn✌️ 鹭雨师傅的博客</a></u></p>
</blockquote>
<h4 id="1-4-1-fread"><a href="#1-4-1-fread" class="headerlink" title="| 1.4.1 | fread"></a>| 1.4.1 | fread</h4><p>主要是 <code>_IO_file_xsgetn</code></p>
<ul>
<li><p><code>fp-&gt;_IO_buf_base</code> 为空的情况，表明此时的 FILE 结构体中的指针未被初始化，输入缓冲区未建立，则调用 <code>_IO_doallocbuf</code> 去初始化指针，建立输入缓冲区</p>
</li>
<li><p><code>have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</code> 表示缓冲区中用户还未读入的数据</p>
<ul>
<li>if want &lt; have &#x3D;&#x3D;&gt; memcpy &#x3D;&#x3D;&gt;  fp-&gt;_IO_read_ptr +&#x3D; want; want &#x3D; 0;return</li>
<li>else if have&gt;0 缓冲区剩下的不够 &#x3D;&#x3D;&gt; memcpy have; want -&#x3D; have; fp-&gt;_IO_read_ptr +&#x3D; have;</li>
<li>if (buf_end - buf_base) &gt; want 到这说明 have 不够了但是如果 buff 长度够用 &#x3D;&#x3D;&gt; call __underflow; continue，调用IO_read把缓冲区填满然后continue，重复</li>
<li>IO_read(fp, s, size)，如果 buff 长度不够，会设置几个指针直接 IO_read，往目标地址(s)读 size ,循环重复</li>
</ul>
</li>
</ul>
<h4 id="1-4-2-fwrite"><a href="#1-4-2-fwrite" class="headerlink" title="| 1.4.2 | fwrite"></a>| 1.4.2 | fwrite</h4><blockquote>
<p>类比 fread, 等做题遇到了以后再写吧</p>
</blockquote>
<hr>
<h2 id="2-利用方法"><a href="#2-利用方法" class="headerlink" title="| 2 | 利用方法"></a>| 2 | 利用方法</h2><blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://dojo.pwn.college/software-exploitation/file-struct-exploits">pwn.college-File Struct Exploits</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/fsop/">ctf-wiki FSOP</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273832.htm">house of apple2</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.kylebot.net/2022/10/22/angry-FSROP/">angry-FSROP</a></p>
</blockquote>
<p>关于 <code>_IO_FILE</code> 在 glibc2.35 的利用现状思考可以看一下上面贴的<code>anrgy-FSROP</code>，感觉读完作者的分析能对 <code>_IO_FILE</code> 的利用有一些理解。</p>
<h3 id="2-1-基于vtable的利用思路"><a href="#2-1-基于vtable的利用思路" class="headerlink" title="| 2.1 | 基于vtable的利用思路"></a>| 2.1 | 基于vtable的利用思路</h3><p>_IO_FILE 攻击主要是通过劫持<code>_IO_list_all</code>或者<code>stderr</code>使其指向我们伪造的 fake_file_struct，使得程序在执行IO函数时，会根据我们伪造的 FILE 结构体来选择，这种攻击方式被称为<code>FSOP</code>(File Stream Orienteded Programming)。<del>面向文件流编程或者说文件流导向编程</del></p>
<p>由于vtable的特殊性，我们通常会在此处做文章劫持程序流，但是在 glibc2.24 加入了 vtable 检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fwrite中的检查，其他的也类似,这是一个叫IO_validate_vtable的函数，但是被定义成了宏？</span></span><br><span class="line"><span class="comment">不是很懂，反正汇编里面没有call而直接写在里面了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline const struct _IO_jump_t *</span></span><br><span class="line"><span class="comment">IO_validate_vtable (const struct _IO_jump_t *vtable)&#123;····&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">https://elixir.bootlin.com/glibc/glibc-2.37/source/libio/libioP.h#L935</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;+<span class="number">131</span>&gt;:   mov    <span class="number">0xd8</span>(%rbx),%r15    <span class="comment">// %rbx = fake_file ,%r15 = fake_file-&gt;vtable</span></span><br><span class="line">&lt;+<span class="number">138</span>&gt;:   lea    <span class="number">0x1959cf</span>(%rip),%rdx    # <span class="number">0x7fce24af8a00</span> &lt;_IO_helper_jumps&gt; <span class="comment">//vtable允许的最小地址</span></span><br><span class="line">&lt;+<span class="number">145</span>&gt;:   lea    <span class="number">0x196730</span>(%rip),%rax    # <span class="number">0x7fce24af9768</span>  <span class="comment">//允许的最大地址</span></span><br><span class="line">&lt;+<span class="number">152</span>&gt;:   sub    %rdx,%rax   <span class="comment">// %rax -= %rdx  即rax为偏移最大值</span></span><br><span class="line">&lt;+<span class="number">155</span>&gt;:   mov    %r15,%rcx   <span class="comment">// %rcx = my_vtable</span></span><br><span class="line">&lt;+<span class="number">158</span>&gt;:   sub    %rdx,%rcx   <span class="comment">// %rcx = my_vtable - %rdx = my_offset</span></span><br><span class="line">&lt;+<span class="number">161</span>&gt;:   cmp    %rcx,%rax   <span class="comment">//比较 rax 和 rcx</span></span><br><span class="line">&lt;+<span class="number">164</span>&gt;:   jbe    &lt;__GI__IO_fwrite+<span class="number">352</span>&gt; <span class="comment">// 以无符号的形式 rax &lt;= rcx 则 jump</span></span><br><span class="line"><span class="comment">//··············</span></span><br><span class="line">&lt;+<span class="number">352</span>&gt;:   call   &lt;_IO_vtable_check&gt;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，我们一般只能在一定范围内修改 FILE 结构体的 vtable。</p>
<p>所以，利用方式通常是：根据目前已经发现的存在漏洞的调用链来伪造 FILE 结构体。</p>
<p>_IO_FILE 的利用简单来说就是如何伪造 FILE 结构体，使得程序按照设定的路线执行到目标位置。</p>
<h4 id="2-1-1-一般伪造结构体有两个主要思路"><a href="#2-1-1-一般伪造结构体有两个主要思路" class="headerlink" title="| 2.1.1 | 一般伪造结构体有两个主要思路:"></a>| 2.1.1 | 一般伪造结构体有两个主要思路:</h4><ul>
<li><p>根据函数源码设置</p>
<p>  在函数体量比较小的时候，这种方法我觉得还是很方便的，不过加上 glibc 的宏定义，有时候这种方法并不太好看其实，可以初步设置某些成员的值。</p>
</li>
<li><p>gdb动态调试</p>
<p>  我个人比较喜欢这种，通过动调在出错位置附近看汇编代码，找到通过的方法，其实也是很方便的思路。</p>
<p>  所以这里贴一些比较好用的gdb指令</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bt <span class="comment">//back trace查看当前的函数调用链</span></span><br><span class="line">b* __fxprintf + <span class="number">171</span> <span class="comment">//断在某个函数的某一行</span></span><br><span class="line">p *(<span class="keyword">struct</span> _IO_FILE_plus *) <span class="number">0x55aaaaaaaaaaaa</span> <span class="comment">//把该地址作为 _IO_FILE_plus 结构体指针打印</span></span><br><span class="line">x/a &amp;_IO_list_all  <span class="comment">//检查(x) &amp;IO_list_all这个地址的内容，以地址(/a)的形式 </span></span><br><span class="line">x/a &amp;<span class="built_in">stderr</span></span><br><span class="line">p/x &amp;_IO_wfile_overflow <span class="comment">//以16进制(/x)打印(p) _IO_wfile_overflow的入口地址</span></span><br><span class="line">search -p <span class="number">0x7fa16799c410</span>    <span class="comment">//查看该地址储存位置，可以用于找vtable</span></span><br><span class="line">disass  <span class="comment">//反汇编当前函数</span></span><br><span class="line">x/<span class="number">30</span>i $rip   <span class="comment">//检查(x)rip($rip)往下30条指令(/i)</span></span><br><span class="line">x/s $rdi    <span class="comment">//检查(x) rdi($rdi)保存的地址指向的值，以字符串的形式(/s)</span></span><br><span class="line">x/<span class="number">30</span>gx $rax <span class="comment">//以四字(/gx) 的形式检查rax 指向的值，显示30项</span></span><br><span class="line">x/gx $rax+<span class="number">0x68</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-1-2-触发-IO-流的操作一般有三种"><a href="#2-1-2-触发-IO-流的操作一般有三种" class="headerlink" title="| 2.1.2 | 触发 IO 流的操作一般有三种"></a>| 2.1.2 | 触发 IO 流的操作一般有三种</h4><ul>
<li><p>调用<code>exit()</code>函数</p>
<img alt="图 1" src="/images/image-20230404122133.png" />  

<img alt="图 1" src="/images/image-20230404121440.png" />  

<p>需要设置：</p>
<p><code>fake_file-&gt;mode !=0</code><br><code>wide_data-&gt;write_ptr &gt; write_base</code><br><code>fake_file-&gt;lock = lock</code> lock的值作为指针,指向的位置值为0且可写</p>
</li>
<li><p>触发<code>__malloc_assert()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">malloc_assert</span><br><span class="line">    --&gt; __fxprintf</span><br><span class="line">        --&gt;__vfxprintf</span><br><span class="line">          ····</span><br><span class="line">            --&gt;&lt;__GI__IO_wdefault_xsputn+<span class="number">92</span>&gt;:    call   *<span class="number">0x18</span>(%rax)</span><br></pre></td></tr></table></figure>

<img alt="图 2" src="/images/image-20230404123240.png" />  

<p>另外<code>malloc_assert()</code>还会调用<code>fflush(stderr)</code></p>
</li>
<li><p>从 <code>main</code> 函数返回</p>
<p>用不多，遇到的话可以根据前面提的看源码或者动调结合来找。</p>
</li>
</ul>
<h3 id="2-2-house-of-apple2"><a href="#2-2-house-of-apple2" class="headerlink" title="| 2.2 | house of apple2"></a>| 2.2 | house of apple2</h3><p>目前为止(glibc2.37)我觉得比较实用的链子是house of apple2，具体可以看上面的参考链接。当然，还有很多不错的链子比如 emma、 kiwi、 banana 等等。</p>
<p>这里主要介绍 house of apple2 中基于<code>_IO_wfile_overflow()</code>这个合法vtable函数的利用思路。</p>
<h4 id="2-2-1-原理分析"><a href="#2-2-1-原理分析" class="headerlink" title="| 2.2.1 | 原理分析"></a>| 2.2.1 | 原理分析</h4><p>虽然在 FILE 结构体中对vtable的合法性进行了检查，但是在 <code>_IO_wide_data</code>结构体中，其对应有一个<code>_wide_vtable</code>成员。</p>
<p>在调用<code>_wide_vtable</code>时没有检查vtable的合法性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>

<p>所以只需要调用到<code>_IO_wide_data-&gt;_wide_vtable</code>即可。</p>
<p><code>(fp + 0xa0)</code> 为 <code>fp-&gt;_wide_data</code> 域，此处的值为 <code>_IO_wide_data</code> 结构体的地址</p>
<p>当<code>fp-&gt;vtable</code>为比如<code>_IO_wfile_overflow()</code>时，则会把<code>fp-&gt;_wide_data</code>作为参数，去执行。</p>
<h4 id="2-2-2-调用链检查绕过"><a href="#2-2-2-调用链检查绕过" class="headerlink" title="| 2.2.2 | 调用链检查绕过"></a>| 2.2.2 | 调用链检查绕过</h4><ul>
<li><p>调用链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_IO_wfile_overflow+<span class="number">608</span>&gt;:   call  &lt;__GI__IO_wdoallocbuf&gt;  </span><br><span class="line">&lt;_IO_wdoallocbuf+<span class="number">43</span>&gt;    callq  *<span class="number">0x68</span>(%rax)  # <span class="comment">//rax为_wide_data-&gt;_wide_vtable(+0xe0)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;_IO_wfile_overflow+<span class="number">27</span>&gt;     testb  $<span class="number">8</span>, %ah  <span class="comment">//fake_io_file.flag = 0x800 或者0</span></span><br><span class="line">&lt;_IO_wfile_overflow+<span class="number">30</span>&gt;     jne    _IO_wfile_overflow+<span class="number">156</span></span><br><span class="line"></span><br><span class="line">&lt;_IO_wfile_overflow+<span class="number">32</span>&gt;    movq   <span class="number">0xa0</span>(%rdi), %rdx  <span class="comment">//%rdx = wide_data</span></span><br><span class="line">&lt;_IO_wfile_overflow+<span class="number">39</span>&gt;    cmpq   $<span class="number">0</span>, <span class="number">0x18</span>(%rdx)  <span class="comment">//*(wide_data +0x18) = 0</span></span><br><span class="line">&lt;_IO_wfile_overflow+<span class="number">44</span>&gt;    je     _IO_wfile_overflow+<span class="number">608</span>   </span><br><span class="line"><span class="comment">//······</span></span><br><span class="line">&lt;_IO_wfile_overflow+<span class="number">608</span>&gt;:   call  &lt;__GI__IO_wdoallocbuf&gt;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-3-如何设置-fake-FILE-结构体"><a href="#2-2-3-如何设置-fake-FILE-结构体" class="headerlink" title="| 2.2.3 | 如何设置 fake FILE 结构体"></a>| 2.2.3 | 如何设置 fake FILE 结构体</h4><ul>
<li><p>首先先要明确，我们要伪造三个结构, <code>FILE</code> 结构体 <code>_IO_wide_data</code> 结构体 以及 <code>_wide_vtable</code></p>
</li>
<li><p>FILE 结构体</p>
<ul>
<li>先根据触发 IO 的条件设置</li>
<li>fake_file-&gt;wide_data(+0xa0) &#x3D; fake_wide_data_addr</li>
<li>fake_file-&gt;vtable &#x3D; 保存_IO_wfile_overflow的一个地址-0x18(看触发 IO 时是调用的那个偏移)</li>
</ul>
</li>
<li><p>_IO_wide_data 结构体</p>
<ul>
<li>fake_wide_data + 0x18 &#x3D; 0</li>
<li>fake_wide_data + 0xe0 &#x3D; fake_vtable_addr</li>
</ul>
</li>
<li><p>_wide_vtable</p>
<ul>
<li>fake_vtable_addr + 0x68的值为A</li>
<li>A的值为目标函数</li>
</ul>
</li>
<li><p>目标函数</p>
<ul>
<li>如果没有沙盒则考虑one_gadget</li>
<li>如果one_gadget不行或者开了沙盒，则考虑<code>setcontext+61</code>结合ROP</li>
</ul>
</li>
</ul>
<h3 id="2-3-基于-fread-和-fwrite-任意地址读写"><a href="#2-3-基于-fread-和-fwrite-任意地址读写" class="headerlink" title="| 2.3 | 基于 fread 和 fwrite 任意地址读写"></a>| 2.3 | 基于 fread 和 fwrite 任意地址读写</h3><h4 id="2-3-1-任意地址写"><a href="#2-3-1-任意地址写" class="headerlink" title="| 2.3.1 | 任意地址写"></a>| 2.3.1 | 任意地址写</h4><p>修改<code>fread(buf,size,nmemb,fp)</code>中的<code>fp-&gt;_IO_buf_base</code>为写入起始地址</p>
<p><code>_IO_buf_end</code>结束地址; 其他 FILE 指针为0</p>
<p>可以利用 pwntools</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">target_addr = <span class="number">0x7fffa0a0a0a0</span></span><br><span class="line">fp = FileStructure()</span><br><span class="line">payload = fp.read(target_addr,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(fp)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-任意地址读"><a href="#2-3-2-任意地址读" class="headerlink" title="| 2.3.2 | 任意地址读"></a>| 2.3.2 | 任意地址读</h4><p>修改<code>flags = 0x800</code></p>
<p><code>fileno = 1 # file descrptor</code></p>
<p><code>_IO_read_end = _IO_write_base = target_addr</code></p>
<p><code>_IO_write_ptr = target_addr + size</code></p>
<p>同样可以利用 pwntools</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">target_addr = <span class="number">0x7fffa0a0a0a0</span></span><br><span class="line">fp = FileStructure()</span><br><span class="line">payload = fp.write(target_addr,<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(fp)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-修改-stdout-泄漏-libc"><a href="#2-3-3-修改-stdout-泄漏-libc" class="headerlink" title="| 2.3.3 | 修改 stdout 泄漏 libc"></a>| 2.3.3 | 修改 stdout 泄漏 libc</h4><blockquote>
<p>参考资料<br><u><a target="_blank" rel="noopener" href="https://n0va-scy.github.io/2019/09/21/IO_FILE/">IO_FILE泄露libc</a></u></p>
</blockquote>
<p>简单来说就是设置 flag &#x3D; 0xfbad1800<br>然后改小 _IO_write_base</p>
<p>使得输出时，把缓冲区前面的内容输出出来</p>
<h4 id="2-3-4-修改-stdin-任意地址写"><a href="#2-3-4-修改-stdin-任意地址写" class="headerlink" title="| 2.3.4 | 修改 stdin 任意地址写"></a>| 2.3.4 | 修改 stdin 任意地址写</h4><blockquote>
<p>参考资料<br><u><a target="_blank" rel="noopener" href="https://ywhkkx.github.io/2022/04/02/IO_FILE源码分析：stdin任意写/">IO_FILE源码分析：stdin任意写</a></u></p>
</blockquote>
<p>简单来说就是改小 stdin的 _IO_buf_base 使其指向 stdin 结构体的某个偏移，然后再一次输入时，</p>
<p>由于 _IO_read_ptr &gt;&#x3D;_IO_read_end 会在 underflow 里重新设置缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/glibc/latest/source/libio/fileops.c#L460</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) <span class="comment">/* 利用的前提 */</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">         fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure>

<p>这时，_IO_read_base 被修改成 之前_IO_buf_bas 的值也就是 _IO_2_1_stdin 的某个偏移</p>
<p>然后读入缓冲区修改 _IO_2_2_stdin结构体，把 buf_base 设置成 hook, buf_end 要足够大不然缓冲区不够大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p *stdin</span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  _flags = -<span class="number">72540021</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x7f41180b5900</span> &lt;_IO_2_1_stdin_+<span class="number">72</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x7f41180b5928</span> &lt;_IO_2_1_stdin_+<span class="number">72</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x7f41180b5900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x7f41180b78a8</span> &lt;local_buf+<span class="number">8</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br></pre></td></tr></table></figure>

<p>然后输入缓冲区使得 _IO_read_ptr &#x3D;_IO_read_end</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p *stdin</span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  _flags = -<span class="number">72540021</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x7f41180b5928</span> &lt;_IO_2_1_stdin_+<span class="number">72</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x7f41180b5928</span> &lt;_IO_2_1_stdin_+<span class="number">72</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x7f41180b5900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x7f41180b78a8</span> &lt;local_buf+<span class="number">8</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br></pre></td></tr></table></figure>

<p>然后再在 underflow 再次设置指针，除了 buf_end 都指向 free_hook，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p *stdin</span><br><span class="line">$<span class="number">5</span> = &#123;</span><br><span class="line">  _flags = -<span class="number">72540021</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_write_end = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x7f41180b78a8</span> &lt;local_buf+<span class="number">8</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br></pre></td></tr></table></figure>

<p>然后系统调用读入缓冲区, 此时输入目标地址(system)，然后 underflow 设置好指针退出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *stdin</span><br><span class="line">$<span class="number">10</span> = &#123;</span><br><span class="line">  _flags = -<span class="number">72540021</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;\240c\323\027A\177&quot;</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x7f41180b77b1</span> &lt;__malloc_initialize_hook+<span class="number">1</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;\240c\323\027A\177&quot;</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;\240c\323\027A\177&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;\240c\323\027A\177&quot;</span>,</span><br><span class="line">  _IO_write_end = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;\240c\323\027A\177&quot;</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x7f41180b77a8</span> &lt;__free_hook&gt; <span class="string">&quot;\240c\323\027A\177&quot;</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x7f41180b78a8</span> &lt;local_buf+<span class="number">8</span>&gt; <span class="string">&quot;&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>参考例题 - <u><a target="_blank" rel="noopener" href="https://github.com/sev1n75/pwn_file/tree/master/2023HIT/scanf">2023HITCTF</a></u></p>
<hr>
<h2 id="3-一些废话"><a href="#3-一些废话" class="headerlink" title="| 3 | 一些废话"></a>| 3 | 一些废话</h2><p>下面是我在学 _IO_FILE 期间写的某种日记，放在最后了。</p>
<h3 id="2023-3-28"><a href="#2023-3-28" class="headerlink" title="2023.3.28"></a>2023.3.28</h3><p>在打昨天的校赛的时候才切实体会到了_IO_FILE利用的目的—–辅助堆溢出,还有一些利用方式</p>
<ul>
<li><p>_IO_FILE的作用:</p>
<ol>
<li><p>在高版本作为<code>__malloc_hooks</code>的代替手段。在能通过堆任意地址写任意值时能够控制程序流getshell或者读flag</p>
</li>
<li><p>提高堆溢出上限。在通过堆漏洞不能做到任意地址写任意值时，比如只能向任意地址写堆地址,通过劫持IO流，达到任意地址写任意值，或者甚至直接getshell</p>
</li>
</ol>
</li>
<li><p>_IO_FILE的利用方式:整体思路是，劫持_IO_list_all,根据题目条件选择合适的调用链再设置FILE结构体关键成员的值，从而达到该链最终指向的漏洞代码(比如可控的函数指针调用)</p>
</li>
</ul>
<p>所以要调整一下IO_FILE的学习思路了，网上各种各样的调用链感觉可以分成上面两类来学，学的时候就主要注意结构体成员是怎么设置的，有源码的看看源码，没有的gdb跟进去看一下原因</p>
<h3 id="2023-4-3"><a href="#2023-4-3" class="headerlink" title="2023.4.3"></a>2023.4.3</h3><p><del>今天为止算是把 _IO_FILE 弄的比较抻展了。</del></p>
<blockquote>
<p>路还远呢 – 2023.11.27</p>
</blockquote>
<p>后面几个方向：kernel pwn, 编译原理+chromium&amp;v8, Fuzzing, IOT</p>
<p><del>先从kernel开始吧</del></p>
<blockquote>
<p>用户态都还没玩明白T_T – 2023.11.27</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/IO-FILE/">_IO_FILE</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">notion-down</a> and
    Theme by <a href="https://github.com/kaedea/hexo-theme-hacker" target="_blank">hexo-theme-hacker</a>
    </br>
    
      &copy; 2023
        sev1n75 &lt;sev1n75@qq.com&gt;
          
  </p>
</footer>
    
  </div>
</div>
</body>
</html>