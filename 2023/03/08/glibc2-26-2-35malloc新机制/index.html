<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
    <title>
      glibc2.26-2.35malloc新机制 | sev1n75 | Binary Exploit</title>

  
  <meta name="author" content="sev1n75">
  

  
  <meta name="description" content="CTF Pwn 选手，以此博客分享技术和学习过程">
  

  
  
  <meta name="keywords" content="heap">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="glibc2.26-2.35malloc新机制"/>

  <meta property="og:site_name" content="sev1n75"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/images/favicon.png" type="image/png" rel="icon">
  <link href="/images/favicon.png" rel="apple-touch-icon" sizes="76x76">
  <link rel="alternate" href="/atom.xml" title="sev1n75" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <link href="https://fonts.lug.ustc.edu.cn/css?family=Lato|Rubik" rel="stylesheet">
  <script src="/js/pangu-407.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>
<script>
  document.addEventListener(' DOMContentLoaded', () => {
    pangu.autoSpacingPage();
  });
</script>

<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">
        sev1n75's Tech Blog
      </a>
    </h1>
    <p class="site-description">
      
        路漫漫其修远兮，吾将上下而求索
          
    </p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">
            主页
          </a></li>
        
        <li><a href="/archives">
            归档
          </a></li>
        
        <li><a href="/tags">
            标签
          </a></li>
        
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>glibc2.26-2.35malloc新机制</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/03/08/glibc2-26-2-35malloc新机制/" rel="bookmark">
        <time class="entry-date published" datetime="2023-03-08T15:46:59.000Z">
          2023-03-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        

<script type="text/javascript">
    function convertRemToPixels(rem) {    
        return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
    window.onscroll = function() {
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop > convertRemToPixels(40)) {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'visible';
        } else {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'hidden';
        }
    }
</script>


<div id="toc" class="toc-article">
      <div class="toc-content">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-text">| 0 | 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%BB%E7%BB%93"><span class="toc-text">| 1 | 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-26-2-31"><span class="toc-text">|1.1| 2.26-2.31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-31-2-35"><span class="toc-text">|1.2| 2.31-2.35</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-26-2-31-2017-x2F-08-x2F-02-2020-x2F-2-x2F-1"><span class="toc-text">| 2 | 2.26-2.31(2017&#x2F;08&#x2F;02-2020&#x2F;2&#x2F;1)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-tcache-key"><span class="toc-text">|2.1| tcache_key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-unsortedbin-%E6%A3%80%E6%9F%A5"><span class="toc-text">|2.2| unsortedbin 检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-top-chunk-size-%E6%A3%80%E6%9F%A5"><span class="toc-text">|2.3| top chunk size 检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-tcache-get%E6%A3%80%E6%9F%A5"><span class="toc-text">|2.4|  tcache_get检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%85%B6%E4%BB%96"><span class="toc-text">|2.5| 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-31-2-35-2020-x2F-2-x2F-1-2022-x2F-2-x2F-3"><span class="toc-text">| 3 | 2.31-2.35(2020&#x2F;2&#x2F;1-2022&#x2F;2&#x2F;3)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Safe-Linking-to-fastbins-and-tcaches"><span class="toc-text">|3.1|  Safe-Linking to fastbins and tcaches </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-tcache-key-%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E5%80%BC%E6%9B%BF%E6%8D%A2%E5%8E%9F%E6%9D%A5%E7%9A%84tcache%E5%9C%B0%E5%9D%80%E4%BD%9C%E4%B8%BAkey-commit"><span class="toc-text">|3.2| tcache_key 使用随机值替换原来的tcache地址作为key commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%A7%BB%E9%99%A4malloc-hooks"><span class="toc-text">|3.3| 移除malloc hooks</span></a></li></ol></li></ol>
      </div>
</div>
<style>
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>



        <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="| 0 | 前言"></a>| 0 | 前言</h2><p>根据 <a target="_blank" rel="noopener" href="https://sourceware.org/git/glibc.git">glibc.git</a>里glibc-2.31,2.35的malloc commit history 总结了从2.26到2.35新增的对heap exploitation有较大影响的commits</p>
<p>第| 1 | 部分简略总结了加入的机制</p>
<p>第| 2 | 和第 | 3 |部分根据commitdiff具体分析各个commit代码</p>
<span id="more"></span>

<h2 id="1-总结"><a href="#1-总结" class="headerlink" title="| 1 | 总结"></a>| 1 | 总结</h2><h3 id="1-1-2-26-2-31"><a href="#1-1-2-26-2-31" class="headerlink" title="|1.1| 2.26-2.31"></a>|1.1| 2.26-2.31</h3><ul>
<li><p>新增了tcache_key机制</p>
<p>  初始化key&#x3D;tcache地址</p>
<p>  取出时清除key</p>
<p>  free的时候如果有key，则遍历当前tcache检查double free</p>
</li>
<li><p>新增malloc的时候,对unsoredtbin检查</p>
<ul>
<li><code>victim</code>,<code>next</code>的大小范围在<code>2*SIZE_SZ</code>和<code>system_mem</code>之间</li>
<li><code>prevsize(next)</code> 必须等于 <code>chunksize(victim)</code></li>
<li><code>bck-&gt;fd</code> 必须等于<code>victim</code> ,<code>victim-&gt;fd</code> 必须等于unsortedbin</li>
<li><code>prev_inuse(next)</code> 必须等于0</li>
</ul>
</li>
<li><p>新增检查<code>chunksize(av-&gt;top)</code>是否小于<code>system_mem</code></p>
</li>
<li><p>新增<code>tcache_get</code>检查count是否大于0</p>
</li>
</ul>
<h3 id="1-2-2-31-2-35"><a href="#1-2-2-31-2-35" class="headerlink" title="|1.2| 2.31-2.35"></a>|1.2| 2.31-2.35</h3><ul>
<li><p>新增fastbins tcaches Safe-Linking机制</p>
<ul>
<li>用<code>PROTECT_PTR(pos,ptr)</code>对<code>fd(tcache_entry)</code>指针进行加密</li>
<li>pos为当前chunk将要存放指针的地址,ptr为要存放的指向下一个chunk的指针</li>
<li><code>PROTECT_PTR(pos,ptr) = (pos &gt;&gt; 12) ^ ptr</code></li>
<li>检查<code>tcache_entry</code>和<code>fastbin-&gt;fd</code>的值有无对其</li>
</ul>
</li>
<li><p>使用相对随机的值作为<code>tcache_key</code></p>
</li>
<li><p>移除malloc hooks</p>
</li>
</ul>
<h2 id="2-2-26-2-31-2017-x2F-08-x2F-02-2020-x2F-2-x2F-1"><a href="#2-2-26-2-31-2017-x2F-08-x2F-02-2020-x2F-2-x2F-1" class="headerlink" title="| 2 | 2.26-2.31(2017&#x2F;08&#x2F;02-2020&#x2F;2&#x2F;1)"></a>| 2 | 2.26-2.31(2017&#x2F;08&#x2F;02-2020&#x2F;2&#x2F;1)</h2><h3 id="2-1-tcache-key"><a href="#2-1-tcache-key" class="headerlink" title="|2.1| tcache_key"></a>|2.1| <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=bcdaad21d4635931d1bd3b54a7894276925d081d">tcache_key</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-2967</span>,<span class="number">6</span> +<span class="number">2967</span>,<span class="number">8</span> @@ mremap_chunk (mchunkptr p, <span class="type">size_t</span> new_size)</span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">+  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line"> &#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-2990</span>,<span class="number">6</span> +<span class="number">2992</span>,<span class="number">11</span> @@ tcache_put (mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><br><span class="line"> &#123;</span><br><span class="line">   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">   assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">+     detect a double free.  */</span></span><br><span class="line">+  e-&gt;key = tcache;     <span class="comment">//初始化key = tcache堆地址</span></span><br><span class="line">+</span><br><span class="line">   e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">   ++(tcache-&gt;counts[tc_idx]);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3005</span>,<span class="number">6</span> +<span class="number">3012</span>,<span class="number">7</span> @@ tcache_get (<span class="type">size_t</span> tc_idx)</span><br><span class="line">   assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">+  e-&gt;key = <span class="literal">NULL</span>;   <span class="comment">//取出时 key清零防止泄漏</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4218</span>,<span class="number">6</span> +<span class="number">4226</span>,<span class="number">26</span> @@ _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">+    <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">+    tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">+       trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">+       2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely coincidence</span></span><br><span class="line"><span class="comment">+       before aborting.  */</span></span><br><span class="line">+    <span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))     <span class="comment">//如果要free的chunk有tcache_key,就遍历</span></span><br><span class="line">+      &#123;</span><br><span class="line">+       tcache_entry *tmp;</span><br><span class="line">+       LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">+       <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">+            tmp;</span><br><span class="line">+            tmp = tmp-&gt;next)</span><br><span class="line">+         <span class="keyword">if</span> (tmp == e)     <span class="comment">//找到地址一样的chunk</span></span><br><span class="line">+           malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">+       <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a few</span></span><br><span class="line"><span class="comment">+          cycles, but don&#x27;t abort.  */</span></span><br><span class="line">+      &#125;</span><br><span class="line">+</span><br><span class="line">     <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-unsortedbin-检查"><a href="#2-2-unsortedbin-检查" class="headerlink" title="|2.2| unsortedbin 检查"></a>|2.2| unsortedbin 检查</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c">unsortedbin完整性检查</a></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3716</span>,<span class="number">11</span> +<span class="number">3716</span>,<span class="number">22</span> @@ _int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  <span class="comment">// for大循环</span></span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; <span class="comment">//当unsortedbin有chunk</span></span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">-           <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">-               || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">-                                   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">-             malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line">+           mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line">+</span><br><span class="line">+           <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)  <span class="comment">//victim太小或大于system_mem</span></span><br><span class="line">+               || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">+             malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">+           <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)    <span class="comment">//next太小或大于system_mem</span></span><br><span class="line">+               || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">+             malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">+           <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))   <span class="comment">//prevsize != chunksize(victim)</span></span><br><span class="line">+             malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">+           <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)    <span class="comment">//bck -&gt;fd != victim 或victim-&gt;fd != unsoretedbin</span></span><br><span class="line">+               || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">+             malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">+           <span class="keyword">if</span> (__glibc_unlikely (prev_inuse(next)))    <span class="comment">//next的prev_inuse != 0</span></span><br><span class="line">+             malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            If a small request, try to use last remainder if it is the</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3775</span>,<span class="number">6</span> +<span class="number">3775</span>,<span class="number">8</span> @@ _int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//前面是第一个for大循环开始，while循环里面遍历unsorted bin 所有chunk的情况下对victim从unsortedbin退链</span></span><br><span class="line">        <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">+          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))    <span class="comment">//新增了对victim-&gt;bk 指向的chunk的检查(但是前面不是检查过了吗)</span></span><br><span class="line">+            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">        unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="://sourceware.org/git/?p=glibc.git;a=commit;h=5b06f538c5aee0389ed034f60d90a8884d6d54de">unsorted chunk 进large bin 检查</a></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3876</span>,<span class="number">10</span> +<span class="number">3876</span>,<span class="number">14</span> @@ _int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">                <span class="keyword">if</span> (fwd != bck) &#123;   <span class="comment">//当前largebin不为空</span></span><br><span class="line"></span><br><span class="line">                    ···</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;</span><br><span class="line">                        (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size)) &#123;   <span class="comment">//bck-&gt;bk最右边那个chunk是最小的，如果比他还小，就加入bck-&gt;bk</span></span><br><span class="line"></span><br><span class="line">                    ···</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果victim size比最右边的大，则用fd_nextsize找到小于等于size的chunk</span></span><br><span class="line">                    <span class="comment">//因为最右边的fb_nextsize 指向的chunk是最大的，从大的往小的找，依次找到刚好小于等于size的chunk，就插在他左边</span></span><br><span class="line"></span><br><span class="line">                    ···</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//插入当前节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)fwd-&gt;size)    <span class="comment">//大小相等插在右边</span></span><br><span class="line"></span><br><span class="line">                        ···</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">else</span> &#123;  <span class="comment">//比fwd更大，fwd就不用改了，更新victim两个_nextsize的值和</span></span><br><span class="line">                        &#123;</span><br><span class="line">                        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                        <span class="comment">//对fwd-&gt;bk_nextsize指向的chunk的fd_nextsize位置的数据进行检查</span></span><br><span class="line">+                          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd)) </span><br><span class="line">+                            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                    bck = fwd-&gt;bk;</span><br><span class="line">                    <span class="comment">//检查bck-&gt;fd位置的数据</span></span><br><span class="line">+                      <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">+                        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            ···</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-top-chunk-size-检查"><a href="#2-3-top-chunk-size-检查" class="headerlink" title="|2.3| top chunk size 检查"></a>|2.3| <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c">top chunk size 检查</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4076</span>,<span class="number">6</span> +<span class="number">4076</span>,<span class="number">9</span> @@ _int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">       <span class="comment">//在切分top的部分</span></span><br><span class="line">       victim = av-&gt;top;</span><br><span class="line">       size = chunksize (victim);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//防止house of force</span></span><br><span class="line">+      <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))    <span class="comment">//如果size被overwrite了一个大于 system_mem的值则会crash</span></span><br><span class="line">+        malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line">+</span><br><span class="line">       <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">         &#123;</span><br><span class="line">           remainder_size = size - nb;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-tcache-get检查"><a href="#2-4-tcache-get检查" class="headerlink" title="|2.4|  tcache_get检查"></a>|2.4| <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f"> tcache_get检查</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-2946</span>,<span class="number">7</span> +<span class="number">2946</span>,<span class="number">7</span> @@ tcache_get (<span class="type">size_t</span> tc_idx)</span><br><span class="line"> &#123;</span><br><span class="line">   tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">   assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">-  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">+  assert (tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">   e-&gt;key = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="|2.5| 其他"></a>|2.5| 其他</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=249a5895f120b13290a372a49bb4b499e749806f">检查malloc_consolidate中chunk的size的合法性</a></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4431</span>,<span class="number">6</span> +<span class="number">4431</span>,<span class="number">12</span> @@ <span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">        maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);    <span class="comment">//maxfb 是指向malloc_chunk*的指针</span></span><br><span class="line">        fb = &amp;fastbin(av, <span class="number">0</span>);   <span class="comment">//从fastbinY[0]开始，用地址是为了方便循环条件设置</span></span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">// 外层循环遍历fastbinY[]里的每一个fastbin </span></span><br><span class="line">            p = atomic_exchange_acq(fb, <span class="number">0</span>); <span class="comment">//malloc_chunk p = * fb</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;   <span class="comment">//fastbinY[i]不空</span></span><br><span class="line">                <span class="keyword">do</span> &#123;    <span class="comment">//内层循环 遍历当前fastbin 里的每一个chunk</span></span><br><span class="line">+                   &#123;</span><br><span class="line">+                     <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">+                     <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">+                       malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">+                   &#125;</span><br><span class="line">+</span><br><span class="line">                    check_inuse_chunk(av, p);</span><br><span class="line">                    nextp = p-&gt;fd;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修复<code>__libc_malloc()</code>在使用tcache时可能出现的整数溢出 <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=8e448310d74b283c5cd02b9ed7fb997b47bf9b22">(commit)</a></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3031</span>,<span class="number">7</span> +<span class="number">3031</span>,<span class="number">8</span> @@ __libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">     <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">   <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">-  <span class="type">size_t</span> tbytes = request2size (bytes);</span><br><span class="line">+  <span class="type">size_t</span> tbytes;</span><br><span class="line">+  checked_request2size (bytes, tbytes);    <span class="comment">//用更安全的宏</span></span><br><span class="line">   <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=1f50f2ad854c84ead522bfc7331b46dbe6057d53">tcache小型优化</a></p>
</li>
</ul>
<br/>

<h2 id="3-2-31-2-35-2020-x2F-2-x2F-1-2022-x2F-2-x2F-3"><a href="#3-2-31-2-35-2020-x2F-2-x2F-1-2022-x2F-2-x2F-3" class="headerlink" title="| 3 | 2.31-2.35(2020&#x2F;2&#x2F;1-2022&#x2F;2&#x2F;3)"></a>| 3 | 2.31-2.35(2020&#x2F;2&#x2F;1-2022&#x2F;2&#x2F;3)</h2><h3 id="3-1-Safe-Linking-to-fastbins-and-tcaches"><a href="#3-1-Safe-Linking-to-fastbins-and-tcaches" class="headerlink" title="|3.1|  Safe-Linking to fastbins and tcaches "></a>|3.1|  <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=a1a486d70ebcc47a686ff5846875eacad0940e41">Safe-Linking to fastbins and tcaches </a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-327</span>,<span class="number">6</span> +<span class="number">327</span>,<span class="number">18</span> @@ __malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line"> <span class="meta"># <span class="keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">+<span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">+   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">+   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">+   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">+   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">+   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">+   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">+   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">+   still works.  */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">+  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))     <span class="comment">//把要存到自己里面的 下一个chunk的地址 用自己的地址加密</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)   <span class="comment">//用自己的地址 把自己存的内容 解密</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-2923</span>,<span class="number">7</span> +<span class="number">2938</span>,<span class="number">7</span> @@ tcache_put (mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><br><span class="line">   e-&gt;key = tcache;</span><br><span class="line"> </span><br><span class="line">-  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">+  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">   ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-2934</span>,<span class="number">9</span> +<span class="number">2949</span>,<span class="number">11</span> @@ <span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"> <span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line"> &#123;</span><br><span class="line">   tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">-  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">+  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">   e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">+  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))  <span class="comment">//检查e地址对其</span></span><br><span class="line">+    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-2960</span>,<span class="number">7</span> +<span class="number">2977</span>,<span class="number">10</span> @@ tcache_thread_shutdown (<span class="type">void</span>)</span><br><span class="line">       <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">        &#123;</span><br><span class="line">          tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">-         tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">+      <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">+       malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span> </span><br><span class="line">+                        <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">+         tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">          __libc_free (e);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3570</span>,<span class="number">8</span> +<span class="number">3590</span>,<span class="number">11</span> @@ _int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">       victim = pp;                                     </span><br><span class="line">       <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)                              </span><br><span class="line">        <span class="keyword">break</span>;                                          </span><br><span class="line">+      pp = REVEAL_PTR (victim-&gt;fd);                                     </span><br><span class="line">+      <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (pp))) <span class="comment">//检查fastbin 对其</span></span><br><span class="line">+       malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); </span><br><span class="line">     &#125;                                                  </span><br><span class="line">-  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) </span><br><span class="line">+  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) </span><br><span class="line">         != victim);                                    </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3583</span>,<span class="number">8</span> +<span class="number">3606</span>,<span class="number">11</span> @@ _int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">+         <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (victim)))</span><br><span class="line">+           malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line">+</span><br><span class="line">          <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">-           *fb = victim-&gt;fd;</span><br><span class="line">+           *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            REMOVE_FB (fb, pp, victim);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3605</span>,<span class="number">8</span> +<span class="number">3631</span>,<span class="number">10</span> @@ _int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">                  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">                  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                         &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">+                     <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tc_victim)))</span><br><span class="line">+                       malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">                      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">-                       *fb = tc_victim-&gt;fd;</span><br><span class="line">+                       *fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          REMOVE_FB (fb, pp, tc_victim);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4196</span>,<span class="number">11</span> +<span class="number">4224</span>,<span class="number">15</span> @@ _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">            LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">            <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">                 tmp;</span><br><span class="line">-                tmp = tmp-&gt;next)</span><br><span class="line">+                tmp = REVEAL_PTR (tmp-&gt;next))</span><br><span class="line">+               &#123;</span><br><span class="line">+                    <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">+                      malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line">                     <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                   <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                      few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">+               &#125;</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4264</span>,<span class="number">7</span> +<span class="number">4296</span>,<span class="number">7</span> @@ _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">           add (i.e., <span class="type">double</span> <span class="built_in">free</span>).  */</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">-       p-&gt;fd = old;</span><br><span class="line">+       p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">        *fb = p;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4274</span>,<span class="number">7</span> +<span class="number">4306</span>,<span class="number">8</span> @@ _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">             add (i.e., <span class="type">double</span> <span class="built_in">free</span>).  */</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">-         p-&gt;fd = old2 = old;</span><br><span class="line">+         old2 = old;</span><br><span class="line">+         p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">             != old2);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4472</span>,<span class="number">13</span> +<span class="number">4505</span>,<span class="number">17</span> @@ <span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">     <span class="title function_">if</span> <span class="params">(p != <span class="number">0</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">+         <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (p)))</span><br><span class="line">+           malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span> </span><br><span class="line">+                            <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line">+</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">          <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        check_inuse_chunk(av, p);</span><br><span class="line">-       nextp = p-&gt;fd;</span><br><span class="line">+       nextp = REVEAL_PTR (p-&gt;fd);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">        size = chunksize (p);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-4896</span>,<span class="number">8</span> +<span class="number">4933</span>,<span class="number">13</span> @@ int_mallinfo (mstate av, <span class="keyword">struct</span> mallinfo *m)</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NFASTBINS; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">-      <span class="keyword">for</span> (p = fastbin (av, i); p != <span class="number">0</span>; p = p-&gt;fd)</span><br><span class="line">+      <span class="keyword">for</span> (p = fastbin (av, i);</span><br><span class="line">+          p != <span class="number">0</span>;</span><br><span class="line">+          p = REVEAL_PTR (p-&gt;fd))</span><br><span class="line">         &#123;</span><br><span class="line">+         <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (p)))</span><br><span class="line">+           malloc_printerr (<span class="string">&quot;int_mallinfo(): &quot;</span> </span><br><span class="line">+                            <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line">           ++nfastblocks;</span><br><span class="line">           fastavail += chunksize (p);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-5437</span>,<span class="number">8</span> +<span class="number">5479</span>,<span class="number">11</span> @@ __malloc_info (<span class="type">int</span> options, FILE *fp)</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">+                 <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (p)))</span><br><span class="line">+                   malloc_printerr (<span class="string">&quot;__malloc_info(): &quot;</span> </span><br><span class="line">+                                    <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line">                  ++nthissize;</span><br><span class="line">-                 p = p-&gt;fd;</span><br><span class="line">+                 p = REVEAL_PTR (p-&gt;fd);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">              fastavail += nthissize * thissize;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-tcache-key-使用随机值替换原来的tcache地址作为key-commit"><a href="#3-2-tcache-key-使用随机值替换原来的tcache地址作为key-commit" class="headerlink" title="|3.2| tcache_key 使用随机值替换原来的tcache地址作为key commit"></a>|3.2| tcache_key 使用随机值替换原来的tcache地址作为key <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=fc859c304898a5ec72e0ba5269ed136ed0ea10e1">commit</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-3108</span>,<span class="number">6</span> +<span class="number">3112</span>,<span class="number">31</span> @@ <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">+<span class="title">static</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">+<span class="title">tcache_key_initialize</span> (<span class="title">void</span>)</span></span><br><span class="line"><span class="class">+&#123;</span></span><br><span class="line">+  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">+      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">+    &#123;</span><br><span class="line">+      tcache_key = random_bits ();</span><br><span class="line">+<span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">+      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-移除malloc-hooks"><a href="#3-3-移除malloc-hooks" class="headerlink" title="|3.3| 移除malloc hooks"></a>|3.3| 移除malloc hooks</h3><p>经过了几个commit之后移除了malloc hooks</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/heap/">heap</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">notion-down</a> and
    Theme by <a href="https://github.com/kaedea/hexo-theme-hacker" target="_blank">hexo-theme-hacker</a>
    </br>
    
      &copy; 2023
        sev1n75 &lt;sev1n75@qq.com&gt;
          
  </p>
</footer>
    
  </div>
</div>
</body>
</html>